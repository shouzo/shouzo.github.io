---
layout: post
title:  "20170519 [學習筆記] Linux 系統程式 (11)"
date:   2017-05-19 00:00:00
categories: Linux 作業系統 程式設計
tags: Linux 作業系統 程式設計
---


* content
{:toc}


## 一、作業系統
* 課堂講義
    * [Chapter 7: Deadlocks](https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170518/ch07.pdf)
    * [Chapter 8: Memory-Management Strategies](https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170518/ch08.pdf)
* 參考資料
    * [Static Linking VS. Dynamic Linking](https://www3.nd.edu/~dthain/courses/classconf/worts2006/WangLiu.ppt)


### (一) Deadlock Detection
* Allow system to enter deadlock state
* Detection algorithm
* Recovery scheme


### (二) Detection Algorithm
![](https://i.imgur.com/LRO7qdP.png)
![](https://i.imgur.com/ZG7BUjD.png)

* **Example**

![](https://i.imgur.com/PBYJ62y.png)
![](https://i.imgur.com/rt4bsYL.png)

* **Usage**
    * When, and how often, to invoke depends on
        * How often a deadlock is likely to occur?
        * How many processes will need to be rolled back?
            * one for each disjoint cycle
    * If detection algorithm is invoked arbitrarily, there may be many cycles in the resource graph and so we would not be able to tell which of the many deadlocked processes “caused” the deadlock.


### (三) Recovery from Deadlock
#### 1. Process Termination
* Abort all deadlocked processes
* Abort one process at a time until the deadlock cycle is eliminated
* In which order should we choose to abort?
    1. Priority of the process
    2. How long process has computed, and how much longer to completion
    3. Resources the process has used
    4. Resources process needs to complete
    5. How many processes will need to be terminated
    6. Is process interactive or batch?

#### 2. Resource Preemption
* **Selecting a victim** - minimize cost
* **Rollback** - return to some safe state, restart process for that state
* **Starvation** - same process may always be picked as victim, include number of rollback in cost factor


### (四) Memory-Management
* Program must be brought (from disk) into memory and placed within a process for it to be run
* Main memory and registers are only storage CPU can access directly
* Memory unit only sees a stream of `addresses + read requests`, or `address + data and write requests`
* Register access in one CPU clock (or less)
* Main memory can take many cycles, causing a **stall**
* **Cache** sits between main memory and CPU registers
* Protection of memory required to ensure correct operation

1. **Base and Limit Registers**
    * A pair of **base** and limit **registers** define the logical address space
    * CPU must check every memory access generated in user mode to be sure it is between base and limit for that user
    ![](https://i.imgur.com/mxLWZHF.png)

    * Hardware Address Protection with Base and Limit Registers
    ![](https://i.imgur.com/ztutE6h.png)

2. **Address Binding**
    * Programs on disk, ready to be brought into memory to execute form an **input queue**
        * Without support, must be loaded into address 0000
    * Inconvenient to have first user process physical address always at 0000
        * How can it not be?
    * Further, addresses represented in different ways at different stages of a program’s life
        * Source code addresses usually symbolic
        * Compiled code addresses **bind** to relocatable addresses
            * i.e. “14 bytes from beginning of this module”
        * Linker or loader will bind relocatable addresses to absolute addresses
            * i.e. 74014
        * Each binding maps one address space to another
        
![](https://i.imgur.com/cXzBuNp.jpg)

3. **Logical vs. Physical Address Space**
![](https://i.imgur.com/LwA18UW.png)

4. **Memory-Management Unit (MMU)**
    * Hardware device that at run time maps virtual to physical address
    * Many methods possible, covered in the rest of this chapter
    * To start, consider simple scheme where the value in the relocation register is added to every address generated by a user process at the time it is sent to memory
        * Base register now called **relocation register**
        * MS-DOS on Intel 80x86 used 4 relocation registers
    * The user program deals with logical addresses; it never sees the real physical addresses
        * Execution-time binding occurs when reference is made to location in memory
        * Logical address bound to physical addresses

5. **Dynamic relocation**
    * Using a relocation register
![](https://i.imgur.com/RICsWcf.png)

6. **Dynamic Linking**
    * **Static linking** - system libraries and program code combined by the loader into the binary program image
    * **Dynamic linking** – linking postponed until execution time
    * Small piece of code, **stub**, used to locate the appropriate memory-resident library routine
    * Stub replaces itself with the address of the routine, and executes the routine
    * Operating system checks if routine is in processes’ memory address
        * If not in address space, add to address space
    * Dynamic linking is particularly useful for libraries
    * System also known as **shared libraries**
    * Consider applicability to patching system libraries
        * Versioning may be needed

7. **Swapping**
    * A process can be swapped temporarily out of memory to a backing store, and then brought back into memory for continued execution
        * Total physical memory space of processes can exceed physical memory
    * **Backing store** – fast disk large enough to accommodate copies of all memory images for all users; must provide direct access to these memory images
    * **Roll out, roll in** – swapping variant used for priority-based scheduling algorithms; lower-priority process is swapped out so higher-priority process can be loaded and executed
    * Major part of swap time is transfer time; total transfer time is directly proportional to the amount of memory swapped
    * System maintains a **ready queue** of ready-to-run processes which have memory images on disk
    * Does the swapped out process need to swap back in to same physical addresses?
        * Depends on address binding method
            * Plus consider pending `I/O` to `/` from process memory space
    * Modified versions of swapping are found on many systems (i.e., UNIX, Linux, and Windows)
        * Swapping normally disabled
        * Started if more than threshold amount of memory allocated
        * Disabled again once memory demand reduced below threshold

![](https://i.imgur.com/hptlmlg.png)




## 二、Linux 程式設計
* 課程簡報
    * [Linux_shell](https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170512/Linux_shell.pdf)
    * [Shell_practice](https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170512/Shell_practice.pdf)
* 參考資料
    * [學習 Shell Scripts](http://linux.vbird.org/linux_basic/0340bashshell-scripts.php#script_why)


### (一) 函數 (Function)
```shell
#!/bin/sh

foo() {
    echo "Function foo is excuting"
}

echo "Script starting"
foo
echo "Script ending"
```

* 執行結果
![](https://i.imgur.com/WPrf3XF.png)


### (二) 命令 (command)
##### Example 1
```shell
#!/bin/sh

for x in 1 2 3
do 
    echo before $x
    continue
    echo after $x
done
```

* 執行結果
![](https://i.imgur.com/3WgXZOC.png)

##### Example 2
```shell
#!/bin/sh

for x in 1 2 3
do 
    echo before $x
    break
    echo after $x
done
```

* 執行結果
![](https://i.imgur.com/DVLkGCC.png)

#### 其他命令
* exit
* export
* expr
* printf
* return
* set
* shift


### (三) 命令 (command) - find
```
-atime N           檔案最後存取時間是 N 天以前
-mtime N           檔案最後修改時間是 N 天以前
-newer otherfle    檔案比 otherfle 還要新
-name pattern      搜尋 pattern 名稱的檔案
-type C            檔案型態是 C 的檔案
-user username     檔案為 username 使用者所擁有
```

> find / -name test -print
> find . -newer test -print


### (四) 命令 (command) - grep
```
-c    不印出吻合的那一行,只印出吻合的數量
-E    開啟延伸表示式
-h    輸出的結果不顯示檔案名稱
-I    忽略大小寫
-l    只列出檔案名稱
-v    反向比對,排除吻合樣本的結果
```

> grep in word.txt
> grep -c in word.txt word2.txt

#### 正規表示式
![](https://i.imgur.com/ZL5A5xf.png)
![](https://i.imgur.com/rLplSSh.png)
