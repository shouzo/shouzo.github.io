I"°{<ul id="markdown-toc">
  <li><a href="#ä¸€ä½œæ¥­ç³»çµ±" id="markdown-toc-ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</a>    <ul>
      <li><a href="#multithread-architecture" id="markdown-toc-multithread-architecture">Multithread Architecture</a></li>
      <li><a href="#ä¸€multicore-programming" id="markdown-toc-ä¸€multicore-programming">ä¸€ã€Multicore Programming</a></li>
      <li><a href="#äºŒconcurrency-vs-parallelism" id="markdown-toc-äºŒconcurrency-vs-parallelism">äºŒã€Concurrency vs Parallelism</a>        <ul>
          <li><a href="#1-concurrency" id="markdown-toc-1-concurrency">1. Concurrency</a></li>
          <li><a href="#2-parallelism" id="markdown-toc-2-parallelism">2. Parallelism</a></li>
          <li><a href="#3-concurrency-vs-parallelism" id="markdown-toc-3-concurrency-vs-parallelism">3. Concurrency vs Parallelism</a></li>
          <li><a href="#4-ç›¸é—œæ•´ç†" id="markdown-toc-4-ç›¸é—œæ•´ç†">4. ç›¸é—œæ•´ç†</a></li>
        </ul>
      </li>
      <li><a href="#ä¸‰single-and-multithreaded-processes" id="markdown-toc-ä¸‰single-and-multithreaded-processes">ä¸‰ã€Single and Multithreaded Processes</a></li>
      <li><a href="#å››user-threads-and-kernel-threads" id="markdown-toc-å››user-threads-and-kernel-threads">å››ã€User Threads and Kernel Threads</a></li>
      <li><a href="#äº”multithreading-models" id="markdown-toc-äº”multithreading-models">äº”ã€Multithreading Models</a></li>
      <li><a href="#å…­pthreads" id="markdown-toc-å…­pthreads">å…­ã€Pthreads</a>        <ul>
          <li><a href="#pthreadh" id="markdown-toc-pthreadh">pthread.h</a>            <ul>
              <li><a href="#pthread_create" id="markdown-toc-pthread_create">pthread_create()</a></li>
              <li><a href="#pthread_exit" id="markdown-toc-pthread_exit">pthread_exit()</a></li>
              <li><a href="#pthread_join" id="markdown-toc-pthread_join">pthread_join()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#èª²ç¨‹ä½œæ¥­" id="markdown-toc-èª²ç¨‹ä½œæ¥­">èª²ç¨‹ä½œæ¥­</a></li>
    </ul>
  </li>
</ul>

<h2 id="ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170323/ch04.pdf">Chapter 4: Mutithread Programming</a></li>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170323/Linux_programming_pthread.pdf">Linux_programming_pthread</a></li>
    </ul>
  </li>
  <li>åƒè€ƒè³‡æ–™
    <ul>
      <li><a href="https://hackmd.io/s/Skh_AaVix">Toward Concurrency</a></li>
      <li><a href="https://chi_gitbook.gitbooks.io/personal-note/content/amdahls_law.html">Amdahlâ€™s Law</a></li>
    </ul>
  </li>
</ul>

<h3 id="multithread-architecture">Multithread Architecture</h3>
<p><img src="https://i.imgur.com/8ICdvBz.jpg" alt="" /></p>
<ul>
  <li><strong>Responsiveness</strong> â€“ may allow continued execution if part of process is blocked, especially important for user interfaces.</li>
  <li><strong>Resource Sharing</strong> â€“ threads share resources of process, easier than shared memory or message passing.</li>
  <li><strong>Economy</strong> â€“ cheaper than process creation, thread switching lower overhead than context switching.</li>
  <li><strong>Scalability</strong> â€“ process can take advantage of multiprocessor architectures.</li>
</ul>

<h3 id="ä¸€multicore-programming">ä¸€ã€Multicore Programming</h3>
<ul>
  <li><strong>Multicore</strong> or <strong>multiprocessor</strong> systems putting pressure on programmers, challenges include:
    <ul>
      <li><strong>Dividing activities</strong></li>
      <li><strong>Balance</strong></li>
      <li><strong>Data splitting</strong></li>
      <li><strong>Data dependency</strong></li>
      <li><strong>Testing and debugging</strong></li>
    </ul>
  </li>
  <li><strong>Parallelism</strong> implies a system can perform more than one task simultaneously.</li>
  <li><strong>Concurrency</strong> supports more than one task making progress.
    <ul>
      <li>Single processor / core, scheduler providing concurrency</li>
    </ul>
  </li>
  <li>Types of parallelism
    <ul>
      <li><strong>Data parallelism</strong> â€“ distributes subsets of the same data across multiple cores, same operation on each.</li>
      <li><strong>Task parallelism</strong> â€“ distributing threads across cores, each thread performing unique operation.</li>
    </ul>
  </li>
  <li>As # of threads grows, so does architectural support for threading.
    <ul>
      <li>CPUs have cores as well as <strong>hardware threads</strong>.</li>
      <li>Consider Oracle SPARC T4 with 8 cores, and 8 hardware threads per core.</li>
    </ul>
  </li>
</ul>

<h3 id="äºŒconcurrency-vs-parallelism">äºŒã€Concurrency vs Parallelism</h3>
<ul>
  <li>å¼•ç”¨è³‡æ–™ï¼š<a href="https://hackmd.io/s/Skh_AaVix">Toward Concurrency</a></li>
  <li><a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not Parallelism</a>, by Rob Pike
    <ul>
      <li><a href="https://talks.golang.org/2012/waza.slide#1">æŠ•å½±ç‰‡</a></li>
      <li><a href="https://www.youtube.com/watch?v=cN_DpYBzKso">éŒ„å½±</a></li>
      <li><a href="http://stackoverflow.com/questions/11700953/concurrency-is-not-parallelism">å¾ŒçºŒ stackoverflow è¨è«–</a></li>
    </ul>
  </li>
  <li>Concurrency å°è»Ÿé«”è¨­è¨ˆçš„å½±éŸ¿
    <ul>
      <li>æƒ³è¦å……åˆ†ä½¿ç”¨åˆ° CPU çš„è³‡æº</li>
      <li>ç¨‹å¼è¶Šä¾†è¶Šæœ‰æ©Ÿæœƒé€ æˆ CPU-boundã€‚é›–ç„¶ä¸»è¦é‚„æ˜¯ IO-bound ç­‰ï¼Œä½†å¦‚æœ CPU æ™‚è„ˆç„¡æ³•å¢åŠ ï¼Œè€Œå…¶ä»–å­˜å–æ–¹å¼é€Ÿåº¦è®Šå¿«ï¼Œæœ€å¾Œæœƒç™¼ç”Ÿ CPU-bound</li>
      <li>è»Ÿé«”æ•ˆèƒ½å„ªåŒ–å°‡æœƒè¶Šä¾†è¶Šé‡è¦</li>
      <li>ç¨‹å¼èªè¨€å¿…é ˆå¥½å¥½è™•ç† concurrency</li>
    </ul>
  </li>
</ul>

<h4 id="1-concurrency">1. Concurrency</h4>
<ul>
  <li>æ˜¯æŒ‡ç¨‹å¼æ¶æ§‹ï¼Œå°‡ç¨‹å¼æ‹†é–‹æˆå¤šå€‹å¯ç¨ç«‹é‹ä½œçš„å·¥ä½œã€‚egï¼šdriversï¼Œéƒ½å¯ä»¥ç¨ç«‹é‹ä½œï¼Œä½†ä¸éœ€è¦å¹³è¡ŒåŒ–ã€‚
    <ul>
      <li>æ‹†é–‹å¤šå€‹çš„å·¥ä½œä¸ä¸€å®šè¦åŒæ™‚é‹è¡Œ</li>
      <li>å¤šå€‹å·¥ä½œåœ¨å–®æ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
    </ul>
  </li>
</ul>

<h4 id="2-parallelism">2. Parallelism</h4>
<ul>
  <li>æ˜¯æŒ‡ç¨‹å¼åŸ·è¡Œï¼ŒåŒæ™‚åŸ·è¡Œå¤šå€‹ç¨‹å¼ã€‚Concurrency å¯èƒ½æœƒç”¨åˆ° parallelismï¼Œä½†ä¸ä¸€å®šè¦ç”¨ parallelism æ‰èƒ½å¯¦ç¾ concurrencyã€‚egï¼šVector dot product
    <ul>
      <li>ç¨‹å¼æœƒåŒæ™‚åŸ·è¡Œ (ä¾‹å¦‚ï¼šåˆ†æ”¯å¾Œï¼ŒåŒæ™‚åŸ·è¡Œï¼Œå†æ”¶é›†çµæœ)</li>
      <li>ä¸€å€‹å·¥ä½œåœ¨å¤šæ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
    </ul>
  </li>
</ul>

<h4 id="3-concurrency-vs-parallelism">3. Concurrency vs Parallelism</h4>
<ul>
  <li>
    <p>Rob Pike ç”¨åœ°é¼ ç‡’æ›¸åšä¾‹å­:
<img src="https://hackpad-attachments.s3.amazonaws.com/embedded2016.hackpad.com_K6DJ0ZtiecH_p.537916_1460613009716_task.jpg" alt="" /></p>
  </li>
  <li>
    <p>å¦‚æœä»Šå¤©å¢åŠ å¤šä¸€åªåœ°é¼ ï¼Œä¸€å€‹æ¨è»Šæˆ–å¤šä¸€å€‹ç„šç‡’ç›§ï¼Œé€™æ¨£æœ‰æ©Ÿæœƒä½œåˆ°æ›´å¥½çš„è³‡æºä½¿ç”¨ç‡ï¼Œä½†æˆ‘å€‘ä¸èƒ½ä¿è­‰å…©åªæˆ–æ›´å¤šåœ°é¼ æœƒåŒæ™‚é€²è¡Œ (å¯èƒ½åªæœ‰æœ‰é™çš„ç«çˆ)ã€‚åœ¨å–®æ ¸ç³»çµ±ä¸­åªèƒ½å…è¨±ä¸€æ¬¡é€²è¡Œä¸€æ¬¡çš„ç‡’æ›¸å·¥ä½œï¼Œé‚£æ¨£å°±æ²’æœ‰æ•ˆç‡äº†ã€‚
<img src="https://i.imgur.com/XTGAK98.jpg" alt="" />
ä»¥ Concurrency çš„æ–¹å¼å»ä½œæ¥­ï¼Œèƒ½å¤ ä»¥ä¸åŒçš„è§£æ§‹æ–¹å¼å»é€²è¡Œï¼Œå¯ä»¥æ˜¯ä¸‰å€‹åœ°é¼ åˆ†åˆ¥è² è²¬ä¸€éƒ¨åˆ†çš„å·¥ä½œ (decomposition)
<img src="https://i.imgur.com/w5Eugs7.jpg" alt="" />
å…¶ä¸­ä¹Ÿå¯ä»¥ Parallelism:
<img src="https://i.imgur.com/3IHX5BT.jpg" alt="" />
æˆ–
<img src="https://i.imgur.com/duEVvNK.jpg" alt="" /></p>
  </li>
</ul>

<p><strong>Concurrency:</strong>Â æ˜¯æŒ‡ç¨‹å¼æ¶æ§‹ï¼Œå°‡ç¨‹å¼æ‹†é–‹æˆå¤šå€‹å¯ç¨ç«‹é‹ä½œçš„å·¥ä½œï¼Œåƒæ˜¯é©…å‹•ç¨‹å¼éƒ½å¯ç¨ç«‹é‹ä½œï¼Œä½†ä¸éœ€è¦å¹³è¡ŒåŒ–</p>
<ul>
  <li>æ‹†é–‹å¤šå€‹çš„å·¥ä½œä¸ä¸€å®šè¦åŒæ™‚é‹è¡Œ</li>
  <li>å¤šå€‹å·¥ä½œåœ¨å–®æ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
</ul>

<p><strong>Parallelism:</strong>Â æ˜¯æŒ‡ç¨‹å¼åŸ·è¡Œï¼ŒåŒæ™‚åŸ·è¡Œå¤šå€‹ç¨‹å¼ã€‚Concurrency å¯èƒ½æœƒç”¨åˆ° parallelismï¼Œä½†ä¸ä¸€å®šè¦ç”¨ parallelism æ‰èƒ½å¯¦ç¾ concurrencyã€‚egï¼šVector dot product</p>
<ul>
  <li>ç¨‹å¼æœƒåŒæ™‚åŸ·è¡Œ (ä¾‹å¦‚ï¼šfork å¾Œï¼ŒåŒæ™‚åŸ·è¡Œï¼Œå†æ”¶é›†çµæœ [join])</li>
  <li>ä¸€å€‹å·¥ä½œåœ¨å¤šæ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
</ul>

<h4 id="4-ç›¸é—œæ•´ç†">4. ç›¸é—œæ•´ç†</h4>
<p>ç·šä¸Šæ•™æ <a href="https://www.youtube.com/watch?v=6jFkNjhJ-Z4">Introduction to OpenMP</a> åšäº†ä»¥ä¸‹æ•´ç†ï¼š</p>

<p>(1) Concurrent (ä¸¦è¡Œ)</p>
<ul>
  <li>å·¥ä½œå¯æ‹†åˆ†æˆã€Œç¨ç«‹åŸ·è¡Œã€çš„éƒ¨ä»½ï¼Œé€™æ¨£ã€Œå¯ä»¥ã€è®“å¾ˆå¤šäº‹æƒ…ä¸€èµ·åšï¼Œä½†æ˜¯ã€Œä¸ä¸€å®šã€è¦çœŸçš„åŒæ™‚åšã€‚ä¸‹æ–¹æƒ…å¢ƒï¼š
<img src="https://i.imgur.com/rweOyiD.png" alt="" />
    <ul>
      <li>å±•ç¤ºå…·æœ‰ä¸¦è¡Œæ€§ï¼Œä½†ä¸å»åŒæ™‚åŸ·è¡Œã€‚</li>
      <li>ä¸¦è¡Œæ€§æ˜¯ç¨®ã€Œæ¶æ§‹ç¨‹å¼ã€çš„æ¦‚å¿µã€‚å¯«ä¸‹ä¸€æ®µç¨‹å¼ä¹‹å‰ï¼Œæ€è€ƒå•é¡Œæ¶æ§‹æ™‚å°±æ±ºå®šå¥½çš„ã€‚</li>
    </ul>
  </li>
</ul>

<p>(2) Parallel (å¹³è¡Œ)</p>
<ul>
  <li>æŠŠè¦åŠƒå¥½ã€èƒ½å¤ ä¸¦è¡Œçš„ç¨‹å¼ï¼Œåˆ†é…çµ¦ä¸åŒåŸ·è¡Œç·’ï¼Œä¸¦è®“ä»–å€‘åŒæ™‚åŸ·è¡Œã€‚
<img src="https://i.imgur.com/Oom3wM5.png" alt="" />
    <ul>
      <li>ã€Œå¹³è¡Œã€æ˜¯ä¸€ç¨®é¸æ“‡ã€‚</li>
    </ul>
  </li>
</ul>

<h3 id="ä¸‰single-and-multithreaded-processes">ä¸‰ã€Single and Multithreaded Processes</h3>
<p><img src="https://i.imgur.com/KLVunhJ.jpg" alt="" /></p>

<ul>
  <li><strong>Amdahlâ€™s Law</strong>
    <ul>
      <li>é‡å°ç³»çµ±è£¡é¢æŸä¸€å€‹ç‰¹å®šçš„å…ƒä»¶äºˆä»¥æœ€ä½³åŒ–ï¼Œå°æ–¼æ•´é«”ç³»çµ±æœ‰å¤šå°‘çš„æ•ˆèƒ½æ”¹è®Šã€‚
  <img src="https://i.imgur.com/E1L6ODN.jpg" alt="" /></li>
      <li>åˆ†æˆå…©éƒ¨ä»½
        <ul>
          <li><strong>æœ‰è¾¦æ³•æ”¹é€²çš„éƒ¨ä»½</strong></li>
          <li><strong>æ²’æœ‰è¾¦æ³•æ”¹é€²çš„éƒ¨ä»½</strong></li>
        </ul>
      </li>
      <li>å› ç‚ºæœ‰ç„¡æ³•æ”¹é€²çš„éƒ¨ä»½ï¼Œæ‰€ä»¥ä¸å¯èƒ½ç„¡é™æå‡ç³»çµ±çš„æŸä¸€å€‹ç‰¹å®šéƒ¨åˆ†çš„æ•ˆç‡ã€‚</li>
    </ul>
  </li>
</ul>

<h3 id="å››user-threads-and-kernel-threads">å››ã€User Threads and Kernel Threads</h3>
<ul>
  <li><strong>User threads</strong>
    <ul>
      <li>Management done by user-level threads library.</li>
    </ul>
  </li>
  <li><strong>Kernel threads</strong>
    <ul>
      <li>Supported by the Kernel.</li>
    </ul>
  </li>
</ul>

<h3 id="äº”multithreading-models">äº”ã€Multithreading Models</h3>
<ol>
  <li><strong>Many-to-One</strong>
    <ul>
      <li>Many user-level threads mapped to single kernel thread.</li>
      <li><strong>One thread blocking causes all to block.</strong></li>
      <li>Multiple threads may not run in parallel on muticore system because only one may be in kernel at a time.</li>
      <li>Examplesï¼š<code class="language-plaintext highlighter-rouge">Solaris Green Threads</code>ã€<code class="language-plaintext highlighter-rouge">GNU Portable Threads</code>
<img src="https://i.imgur.com/dwfuxrT.jpg" alt="" /></li>
    </ul>
  </li>
  <li><strong>One-to-One</strong>
    <ul>
      <li>Each user-level thread maps to kernel thread.</li>
      <li><strong>Creating a user-level thread creates a kernel thread.</strong></li>
      <li>More concurrency than many-to-one.</li>
      <li>Number of threads per process sometimes restricted due to overhead.</li>
      <li>Examplesï¼š<code class="language-plaintext highlighter-rouge">Windows NT/XP/2000</code>ã€<code class="language-plaintext highlighter-rouge">Linux</code>ã€<code class="language-plaintext highlighter-rouge">Solaris 9 and later</code>
<img src="https://i.imgur.com/Fh9QH0S.jpg" alt="" /></li>
    </ul>
  </li>
  <li><strong>Many-to-Many</strong>
    <ul>
      <li>Allows many user level threads to be mapped to many kernel threads.</li>
      <li>Allows the operating system to create a sufficient number of kernel threads.</li>
      <li>Solaris prior to version 9.</li>
      <li>Exampleï¼š<code class="language-plaintext highlighter-rouge">Windows NT/2000 with the ThreadFiber package</code>
<img src="https://i.imgur.com/hWCuKOk.jpg" alt="" /></li>
    </ul>
  </li>
  <li><strong>Two-level</strong>
    <ul>
      <li>Similar to M:M, except that it allows a user thread to be bound to kernel thread.</li>
      <li>Examplesï¼š<code class="language-plaintext highlighter-rouge">IRIX</code>ã€<code class="language-plaintext highlighter-rouge">HP-UX</code>ã€<code class="language-plaintext highlighter-rouge">Tru64 UNIX</code>ã€<code class="language-plaintext highlighter-rouge">Solaris 8 and earlier</code>
<img src="https://i.imgur.com/iRt3Xj2.jpg" alt="" /></li>
    </ul>
  </li>
</ol>

<h3 id="å…­pthreads">å…­ã€Pthreads</h3>
<ul>
  <li>May be provided either as user-level or kernel-level.</li>
  <li>A POSIX standard (IEEE 1003.1c) API for thread creation and synchronization.</li>
  <li><strong>Specification, not implementation.</strong></li>
  <li>API specifies behavior of the thread library, implementation is up to development of the library.</li>
  <li>Common in UNIX operating systems (Solaris, Linux, Mac OS X).</li>
</ul>

<h4 id="pthreadh">pthread.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="n">pthread_attr_t</span>
<span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="c1">//create a thread</span>


<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
<span class="c1">//terminate a thread</span>


<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
<span class="c1">//wait for thread termination</span>

</code></pre></div></div>

<h5 id="pthread_create">pthread_create()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
<span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span>
<span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t *thread</code>ï¼šthread çš„è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_attr_t *attr</code>ï¼šthread çš„å±¬æ€§ï¼Œè¨­å®šç‚º NULL è¡¨ç¤ºä½¿ç”¨é è¨­å€¼</li>
  <li><code class="language-plaintext highlighter-rouge">void *(*start_routine)(void*)</code>ï¼šthread è¦åŸ·è¡Œçš„ function</li>
  <li><code class="language-plaintext highlighter-rouge">void *arg</code>ï¼šå‚³éçµ¦ thread çš„åƒæ•¸</li>
</ul>

<h5 id="pthread_exit">pthread_exit()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">void *retval</code>ï¼šthread çµæŸæ™‚å›å‚³çš„è®Šæ•¸</li>
</ul>

<h5 id="pthread_join">pthread_join()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t th</code>ï¼šthread è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">void **thread_return</code>ï¼šæ¥æ”¶ pthread_exit å‚³å›çš„è®Šæ•¸</li>
</ul>

<h3 id="èª²ç¨‹ä½œæ¥­">èª²ç¨‹ä½œæ¥­</h3>
<ul>
  <li>å¾ 1 - 10000 ä¹‹é–“å–å‡ºæ‰€æœ‰çš„è³ªæ•¸ï¼Œåˆ©ç”¨ threads ä¾†åˆ†é…è¨ˆç®—è³ªæ•¸çš„ç¯„åœã€‚</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt; 
#include &lt;time.h&gt;
</span>
<span class="cp">#define NUM_THREADS 10
#define MSIZE 10000
</span>
<span class="c1">// æ‰¾å‡º 1 - 10000 çš„æ‰€æœ‰è³ªæ•¸</span>

<span class="k">static</span> <span class="kt">double</span> <span class="nf">getDoubleTime</span><span class="p">();</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="n">pthread_mutex_t</span> <span class="n">work_mutex</span><span class="p">;</span>

<span class="c1">// å®£å‘Š prime_array é™£åˆ—</span>
<span class="kt">int</span> <span class="n">prime_array</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">][(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">)];</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">pthread_t</span> <span class="n">a_thread</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">thread_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lots_of_threads</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">print_prime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="c1">// start to measure time...</span>
	<span class="kt">double</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">getDoubleTime</span><span class="p">();</span>
	
	<span class="c1">// initialize mutex...</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work_mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
       	<span class="n">perror</span><span class="p">(</span><span class="s">"Mutex initialization failed"</span><span class="p">);</span>
	    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

	<span class="c1">// pthread_create...</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lots_of_threads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">a_thread</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">]),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_function</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">lots_of_threads</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"Thread creation failed"</span><span class="p">);</span>
        		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// pthread_join...</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lots_of_threads</span> <span class="o">=</span> <span class="n">NUM_THREADS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lots_of_threads</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        	<span class="n">res</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">a_thread</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">thread_result</span><span class="p">);</span> 

            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	            <span class="n">perror</span><span class="p">(</span><span class="s">"pthread_join failed"</span><span class="p">);</span>
        	<span class="p">}</span>
    <span class="p">}</span>	
    
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// è¨­å®šè¨ˆæ•¸å™¨</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">lots_of_threads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">The thread[%d]'s numbersï¼š</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lots_of_threads</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prime_array</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">prime_array</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>                        <span class="p">}</span>
    <span class="p">}</span>


	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Thread joined</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="c1">// stop measuring time...</span>
	<span class="kt">double</span> <span class="n">finish_time</span> <span class="o">=</span> <span class="n">getDoubleTime</span><span class="p">();</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Execute Time:  %.3lf ms</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">finish_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">));</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// pthread_mutex_lock(&amp;work_mutex);</span>
	
    <span class="kt">int</span> <span class="n">my_num</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="c1">// if (MSIZE % NUM_THREADS != 0){    printf("error");   pthread_exit(-1);    }</span>

    <span class="kt">int</span> <span class="n">start_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">)</span> <span class="o">*</span> <span class="n">my_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">my_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Set the loop</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// Set the counter</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// result</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"I'm thread[%d], start_num:%d, end_num:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_num</span><span class="p">,</span> <span class="n">start_num</span><span class="p">,</span> <span class="n">end_num</span><span class="p">);</span>

    <span class="cm">/* find the prime number */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// Reset counter</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> 
            <span class="n">prime_array</span><span class="p">[</span><span class="n">my_num</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="c1">// pthread_mutex_unlock(&amp;work_mutex);</span>
	<span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">double</span> <span class="nf">getDoubleTime</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tm_tv</span><span class="p">;</span>
        <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_tv</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(((</span><span class="kt">double</span><span class="p">)</span><span class="n">tm_tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">1000</span><span class="p">.</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">tm_tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<ul>
  <li>åŸ·è¡Œçµæœ
<img src="https://i.imgur.com/jw2pSxj.jpg" alt="" /></li>
</ul>
:ET