I"jÕ<ul id="markdown-toc">
  <li><a href="#ä¸€ä½œæ¥­ç³»çµ±" id="markdown-toc-ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</a>    <ul>
      <li><a href="#multithread-architecture" id="markdown-toc-multithread-architecture">Multithread Architecture</a></li>
      <li><a href="#ä¸€multicore-programming" id="markdown-toc-ä¸€multicore-programming">ä¸€ã€Multicore Programming</a></li>
      <li><a href="#äºŒconcurrency-vs-parallelism" id="markdown-toc-äºŒconcurrency-vs-parallelism">äºŒã€Concurrency vs Parallelism</a>        <ul>
          <li><a href="#1-concurrency" id="markdown-toc-1-concurrency">1. Concurrency</a></li>
          <li><a href="#2-parallelism" id="markdown-toc-2-parallelism">2. Parallelism</a></li>
          <li><a href="#3-concurrency-vs-parallelism" id="markdown-toc-3-concurrency-vs-parallelism">3. Concurrency vs Parallelism</a></li>
          <li><a href="#4-ç›¸é—œæ•´ç†" id="markdown-toc-4-ç›¸é—œæ•´ç†">4. ç›¸é—œæ•´ç†</a></li>
        </ul>
      </li>
      <li><a href="#ä¸‰single-and-multithreaded-processes" id="markdown-toc-ä¸‰single-and-multithreaded-processes">ä¸‰ã€Single and Multithreaded Processes</a></li>
      <li><a href="#å››user-threads-and-kernel-threads" id="markdown-toc-å››user-threads-and-kernel-threads">å››ã€User Threads and Kernel Threads</a></li>
      <li><a href="#äº”multithreading-models" id="markdown-toc-äº”multithreading-models">äº”ã€Multithreading Models</a></li>
      <li><a href="#å…­pthreads" id="markdown-toc-å…­pthreads">å…­ã€Pthreads</a>        <ul>
          <li><a href="#pthreadh" id="markdown-toc-pthreadh">pthread.h</a>            <ul>
              <li><a href="#pthread_create" id="markdown-toc-pthread_create">pthread_create()</a></li>
              <li><a href="#pthread_exit" id="markdown-toc-pthread_exit">pthread_exit()</a></li>
              <li><a href="#pthread_join" id="markdown-toc-pthread_join">pthread_join()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#èª²ç¨‹ä½œæ¥­" id="markdown-toc-èª²ç¨‹ä½œæ¥­">èª²ç¨‹ä½œæ¥­</a></li>
    </ul>
  </li>
  <li><a href="#äºŒlinux-ç¨‹å¼è¨­è¨ˆ" id="markdown-toc-äºŒlinux-ç¨‹å¼è¨­è¨ˆ">äºŒã€Linux ç¨‹å¼è¨­è¨ˆ</a>    <ul>
      <li><a href="#ä¸€pthreads" id="markdown-toc-ä¸€pthreads">ä¸€ã€Pthreads</a>        <ul>
          <li><a href="#pthreadh-1" id="markdown-toc-pthreadh-1">pthread.h</a>            <ul>
              <li><a href="#pthread_create-1" id="markdown-toc-pthread_create-1">pthread_create()</a></li>
              <li><a href="#pthread_exit-1" id="markdown-toc-pthread_exit-1">pthread_exit()</a></li>
              <li><a href="#pthread_join-1" id="markdown-toc-pthread_join-1">pthread_join()</a></li>
              <li><a href="#pthread_setcancelstate" id="markdown-toc-pthread_setcancelstate">pthread_setcancelstate()</a></li>
              <li><a href="#pthread_setcanceltype" id="markdown-toc-pthread_setcanceltype">pthread_setcanceltype()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#äºŒcondition-variables" id="markdown-toc-äºŒcondition-variables">äºŒã€Condition Variables</a>        <ul>
          <li><a href="#pthread_cond_init-condition-attr" id="markdown-toc-pthread_cond_init-condition-attr">pthread_cond_init (condition, attr)</a></li>
          <li><a href="#pthread_cond_destroy-condition" id="markdown-toc-pthread_cond_destroy-condition">pthread_cond_destroy (condition)</a></li>
          <li><a href="#pthread_condattr_init-attr" id="markdown-toc-pthread_condattr_init-attr">pthread_condattr_init (attr)</a></li>
          <li><a href="#pthread_condattr_destroy-attr" id="markdown-toc-pthread_condattr_destroy-attr">pthread_condattr_destroy (attr)</a></li>
        </ul>
      </li>
      <li><a href="#ä¸‰thread-synchronization" id="markdown-toc-ä¸‰thread-synchronization">ä¸‰ã€Thread Synchronization</a></li>
      <li><a href="#1-semaphore" id="markdown-toc-1-semaphore">1. Semaphore</a>        <ul>
          <li><a href="#semaphoreh" id="markdown-toc-semaphoreh">semaphore.h</a>            <ul>
              <li><a href="#sem_init" id="markdown-toc-sem_init">sem_init()</a></li>
              <li><a href="#sem_wait" id="markdown-toc-sem_wait">sem_wait()</a></li>
              <li><a href="#sem_post" id="markdown-toc-sem_post">sem_post()</a></li>
              <li><a href="#sem_destroy" id="markdown-toc-sem_destroy">sem_destroy()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#2-mutex" id="markdown-toc-2-mutex">2. Mutex</a>        <ul>
          <li><a href="#pthreadh-2" id="markdown-toc-pthreadh-2">pthread.h</a>            <ul>
              <li><a href="#pthread_mutex_init" id="markdown-toc-pthread_mutex_init">pthread_mutex_init()</a></li>
              <li><a href="#pthread_mutex_lock" id="markdown-toc-pthread_mutex_lock">pthread_mutex_lock()</a></li>
              <li><a href="#pthread_mutex_unlock" id="markdown-toc-pthread_mutex_unlock">pthread_mutex_unlock()</a></li>
              <li><a href="#pthread_mutex_destroy" id="markdown-toc-pthread_mutex_destroy">pthread_mutex_destroy()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#èª²ç¨‹ä½œæ¥­-1" id="markdown-toc-èª²ç¨‹ä½œæ¥­-1">èª²ç¨‹ä½œæ¥­</a></li>
    </ul>
  </li>
</ul>

<h2 id="ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170323/ch04.pdf">Chapter 4: Mutithread Programming</a></li>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170323/Linux_programming_pthread.pdf">Linux_programming_pthread</a></li>
    </ul>
  </li>
  <li>åƒè€ƒè³‡æ–™
    <ul>
      <li><a href="https://hackmd.io/s/Skh_AaVix">Toward Concurrency</a></li>
      <li><a href="https://chi_gitbook.gitbooks.io/personal-note/content/amdahls_law.html">Amdahlâ€™s Law</a></li>
    </ul>
  </li>
</ul>

<h3 id="multithread-architecture">Multithread Architecture</h3>
<p><img src="https://i.imgur.com/8ICdvBz.jpg" alt="" /></p>
<ul>
  <li><strong>Responsiveness</strong> â€“ may allow continued execution if part of process is blocked, especially important for user interfaces.</li>
  <li><strong>Resource Sharing</strong> â€“ threads share resources of process, easier than shared memory or message passing.</li>
  <li><strong>Economy</strong> â€“ cheaper than process creation, thread switching lower overhead than context switching.</li>
  <li><strong>Scalability</strong> â€“ process can take advantage of multiprocessor architectures.</li>
</ul>

<h3 id="ä¸€multicore-programming">ä¸€ã€Multicore Programming</h3>
<ul>
  <li><strong>Multicore</strong> or <strong>multiprocessor</strong> systems putting pressure on programmers, challenges include:
    <ul>
      <li><strong>Dividing activities</strong></li>
      <li><strong>Balance</strong></li>
      <li><strong>Data splitting</strong></li>
      <li><strong>Data dependency</strong></li>
      <li><strong>Testing and debugging</strong></li>
    </ul>
  </li>
  <li><strong>Parallelism</strong> implies a system can perform more than one task simultaneously.</li>
  <li><strong>Concurrency</strong> supports more than one task making progress.
    <ul>
      <li>Single processor / core, scheduler providing concurrency</li>
    </ul>
  </li>
  <li>Types of parallelism
    <ul>
      <li><strong>Data parallelism</strong> â€“ distributes subsets of the same data across multiple cores, same operation on each.</li>
      <li><strong>Task parallelism</strong> â€“ distributing threads across cores, each thread performing unique operation.</li>
    </ul>
  </li>
  <li>As # of threads grows, so does architectural support for threading.
    <ul>
      <li>CPUs have cores as well as <strong>hardware threads</strong>.</li>
      <li>Consider Oracle SPARC T4 with 8 cores, and 8 hardware threads per core.</li>
    </ul>
  </li>
</ul>

<h3 id="äºŒconcurrency-vs-parallelism">äºŒã€Concurrency vs Parallelism</h3>
<ul>
  <li>å¼•ç”¨è³‡æ–™ï¼š<a href="https://hackmd.io/s/Skh_AaVix">Toward Concurrency</a></li>
  <li><a href="https://blog.golang.org/concurrency-is-not-parallelism">Concurrency is not Parallelism</a>, by Rob Pike
    <ul>
      <li><a href="https://talks.golang.org/2012/waza.slide#1">æŠ•å½±ç‰‡</a></li>
      <li><a href="https://www.youtube.com/watch?v=cN_DpYBzKso">éŒ„å½±</a></li>
      <li><a href="http://stackoverflow.com/questions/11700953/concurrency-is-not-parallelism">å¾ŒçºŒ stackoverflow è¨è«–</a></li>
    </ul>
  </li>
  <li>Concurrency å°è»Ÿé«”è¨­è¨ˆçš„å½±éŸ¿
    <ul>
      <li>æƒ³è¦å……åˆ†ä½¿ç”¨åˆ° CPU çš„è³‡æº</li>
      <li>ç¨‹å¼è¶Šä¾†è¶Šæœ‰æ©Ÿæœƒé€ æˆ CPU-boundã€‚é›–ç„¶ä¸»è¦é‚„æ˜¯ IO-bound ç­‰ï¼Œä½†å¦‚æœ CPU æ™‚è„ˆç„¡æ³•å¢åŠ ï¼Œè€Œå…¶ä»–å­˜å–æ–¹å¼é€Ÿåº¦è®Šå¿«ï¼Œæœ€å¾Œæœƒç™¼ç”Ÿ CPU-bound</li>
      <li>è»Ÿé«”æ•ˆèƒ½å„ªåŒ–å°‡æœƒè¶Šä¾†è¶Šé‡è¦</li>
      <li>ç¨‹å¼èªè¨€å¿…é ˆå¥½å¥½è™•ç† concurrency</li>
    </ul>
  </li>
</ul>

<h4 id="1-concurrency">1. Concurrency</h4>
<ul>
  <li>æ˜¯æŒ‡ç¨‹å¼æ¶æ§‹ï¼Œå°‡ç¨‹å¼æ‹†é–‹æˆå¤šå€‹å¯ç¨ç«‹é‹ä½œçš„å·¥ä½œã€‚egï¼šdriversï¼Œéƒ½å¯ä»¥ç¨ç«‹é‹ä½œï¼Œä½†ä¸éœ€è¦å¹³è¡ŒåŒ–ã€‚
    <ul>
      <li>æ‹†é–‹å¤šå€‹çš„å·¥ä½œä¸ä¸€å®šè¦åŒæ™‚é‹è¡Œ</li>
      <li>å¤šå€‹å·¥ä½œåœ¨å–®æ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
    </ul>
  </li>
</ul>

<h4 id="2-parallelism">2. Parallelism</h4>
<ul>
  <li>æ˜¯æŒ‡ç¨‹å¼åŸ·è¡Œï¼ŒåŒæ™‚åŸ·è¡Œå¤šå€‹ç¨‹å¼ã€‚Concurrency å¯èƒ½æœƒç”¨åˆ° parallelismï¼Œä½†ä¸ä¸€å®šè¦ç”¨ parallelism æ‰èƒ½å¯¦ç¾ concurrencyã€‚egï¼šVector dot product
    <ul>
      <li>ç¨‹å¼æœƒåŒæ™‚åŸ·è¡Œ (ä¾‹å¦‚ï¼šåˆ†æ”¯å¾Œï¼ŒåŒæ™‚åŸ·è¡Œï¼Œå†æ”¶é›†çµæœ)</li>
      <li>ä¸€å€‹å·¥ä½œåœ¨å¤šæ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
    </ul>
  </li>
</ul>

<h4 id="3-concurrency-vs-parallelism">3. Concurrency vs Parallelism</h4>
<ul>
  <li>
    <p>Rob Pike ç”¨åœ°é¼ ç‡’æ›¸åšä¾‹å­:
<img src="https://hackpad-attachments.s3.amazonaws.com/embedded2016.hackpad.com_K6DJ0ZtiecH_p.537916_1460613009716_task.jpg" alt="" /></p>
  </li>
  <li>
    <p>å¦‚æœä»Šå¤©å¢åŠ å¤šä¸€åªåœ°é¼ ï¼Œä¸€å€‹æ¨è»Šæˆ–å¤šä¸€å€‹ç„šç‡’ç›§ï¼Œé€™æ¨£æœ‰æ©Ÿæœƒä½œåˆ°æ›´å¥½çš„è³‡æºä½¿ç”¨ç‡ï¼Œä½†æˆ‘å€‘ä¸èƒ½ä¿è­‰å…©åªæˆ–æ›´å¤šåœ°é¼ æœƒåŒæ™‚é€²è¡Œ (å¯èƒ½åªæœ‰æœ‰é™çš„ç«çˆ)ã€‚åœ¨å–®æ ¸ç³»çµ±ä¸­åªèƒ½å…è¨±ä¸€æ¬¡é€²è¡Œä¸€æ¬¡çš„ç‡’æ›¸å·¥ä½œï¼Œé‚£æ¨£å°±æ²’æœ‰æ•ˆç‡äº†ã€‚
<img src="https://i.imgur.com/XTGAK98.jpg" alt="" />
ä»¥ Concurrency çš„æ–¹å¼å»ä½œæ¥­ï¼Œèƒ½å¤ ä»¥ä¸åŒçš„è§£æ§‹æ–¹å¼å»é€²è¡Œï¼Œå¯ä»¥æ˜¯ä¸‰å€‹åœ°é¼ åˆ†åˆ¥è² è²¬ä¸€éƒ¨åˆ†çš„å·¥ä½œ (decomposition)
<img src="https://i.imgur.com/w5Eugs7.jpg" alt="" />
å…¶ä¸­ä¹Ÿå¯ä»¥ Parallelism:
<img src="https://i.imgur.com/3IHX5BT.jpg" alt="" />
æˆ–
<img src="https://i.imgur.com/duEVvNK.jpg" alt="" /></p>
  </li>
</ul>

<p><strong>Concurrency:</strong>Â æ˜¯æŒ‡ç¨‹å¼æ¶æ§‹ï¼Œå°‡ç¨‹å¼æ‹†é–‹æˆå¤šå€‹å¯ç¨ç«‹é‹ä½œçš„å·¥ä½œï¼Œåƒæ˜¯é©…å‹•ç¨‹å¼éƒ½å¯ç¨ç«‹é‹ä½œï¼Œä½†ä¸éœ€è¦å¹³è¡ŒåŒ–</p>
<ul>
  <li>æ‹†é–‹å¤šå€‹çš„å·¥ä½œä¸ä¸€å®šè¦åŒæ™‚é‹è¡Œ</li>
  <li>å¤šå€‹å·¥ä½œåœ¨å–®æ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
</ul>

<p><strong>Parallelism:</strong>Â æ˜¯æŒ‡ç¨‹å¼åŸ·è¡Œï¼ŒåŒæ™‚åŸ·è¡Œå¤šå€‹ç¨‹å¼ã€‚Concurrency å¯èƒ½æœƒç”¨åˆ° parallelismï¼Œä½†ä¸ä¸€å®šè¦ç”¨ parallelism æ‰èƒ½å¯¦ç¾ concurrencyã€‚egï¼šVector dot product</p>
<ul>
  <li>ç¨‹å¼æœƒåŒæ™‚åŸ·è¡Œ (ä¾‹å¦‚ï¼šfork å¾Œï¼ŒåŒæ™‚åŸ·è¡Œï¼Œå†æ”¶é›†çµæœ [join])</li>
  <li>ä¸€å€‹å·¥ä½œåœ¨å¤šæ ¸å¿ƒ CPU ä¸Šé‹è¡Œ</li>
</ul>

<h4 id="4-ç›¸é—œæ•´ç†">4. ç›¸é—œæ•´ç†</h4>
<p>ç·šä¸Šæ•™æ <a href="https://www.youtube.com/watch?v=6jFkNjhJ-Z4">Introduction to OpenMP</a> åšäº†ä»¥ä¸‹æ•´ç†ï¼š</p>

<p>(1) Concurrent (ä¸¦è¡Œ)</p>
<ul>
  <li>å·¥ä½œå¯æ‹†åˆ†æˆã€Œç¨ç«‹åŸ·è¡Œã€çš„éƒ¨ä»½ï¼Œé€™æ¨£ã€Œå¯ä»¥ã€è®“å¾ˆå¤šäº‹æƒ…ä¸€èµ·åšï¼Œä½†æ˜¯ã€Œä¸ä¸€å®šã€è¦çœŸçš„åŒæ™‚åšã€‚ä¸‹æ–¹æƒ…å¢ƒï¼š
<img src="https://i.imgur.com/rweOyiD.png" alt="" />
    <ul>
      <li>å±•ç¤ºå…·æœ‰ä¸¦è¡Œæ€§ï¼Œä½†ä¸å»åŒæ™‚åŸ·è¡Œã€‚</li>
      <li>ä¸¦è¡Œæ€§æ˜¯ç¨®ã€Œæ¶æ§‹ç¨‹å¼ã€çš„æ¦‚å¿µã€‚å¯«ä¸‹ä¸€æ®µç¨‹å¼ä¹‹å‰ï¼Œæ€è€ƒå•é¡Œæ¶æ§‹æ™‚å°±æ±ºå®šå¥½çš„ã€‚</li>
    </ul>
  </li>
</ul>

<p>(2) Parallel (å¹³è¡Œ)</p>
<ul>
  <li>æŠŠè¦åŠƒå¥½ã€èƒ½å¤ ä¸¦è¡Œçš„ç¨‹å¼ï¼Œåˆ†é…çµ¦ä¸åŒåŸ·è¡Œç·’ï¼Œä¸¦è®“ä»–å€‘åŒæ™‚åŸ·è¡Œã€‚
<img src="https://i.imgur.com/Oom3wM5.png" alt="" />
    <ul>
      <li>ã€Œå¹³è¡Œã€æ˜¯ä¸€ç¨®é¸æ“‡ã€‚</li>
    </ul>
  </li>
</ul>

<h3 id="ä¸‰single-and-multithreaded-processes">ä¸‰ã€Single and Multithreaded Processes</h3>
<p><img src="https://i.imgur.com/KLVunhJ.jpg" alt="" /></p>

<ul>
  <li><strong>Amdahlâ€™s Law</strong>
    <ul>
      <li>é‡å°ç³»çµ±è£¡é¢æŸä¸€å€‹ç‰¹å®šçš„å…ƒä»¶äºˆä»¥æœ€ä½³åŒ–ï¼Œå°æ–¼æ•´é«”ç³»çµ±æœ‰å¤šå°‘çš„æ•ˆèƒ½æ”¹è®Šã€‚
  <img src="https://i.imgur.com/E1L6ODN.jpg" alt="" /></li>
      <li>åˆ†æˆå…©éƒ¨ä»½
        <ul>
          <li><strong>æœ‰è¾¦æ³•æ”¹é€²çš„éƒ¨ä»½</strong></li>
          <li><strong>æ²’æœ‰è¾¦æ³•æ”¹é€²çš„éƒ¨ä»½</strong></li>
        </ul>
      </li>
      <li>å› ç‚ºæœ‰ç„¡æ³•æ”¹é€²çš„éƒ¨ä»½ï¼Œæ‰€ä»¥ä¸å¯èƒ½ç„¡é™æå‡ç³»çµ±çš„æŸä¸€å€‹ç‰¹å®šéƒ¨åˆ†çš„æ•ˆç‡ã€‚</li>
    </ul>
  </li>
</ul>

<h3 id="å››user-threads-and-kernel-threads">å››ã€User Threads and Kernel Threads</h3>
<ul>
  <li><strong>User threads</strong>
    <ul>
      <li>Management done by user-level threads library.</li>
    </ul>
  </li>
  <li><strong>Kernel threads</strong>
    <ul>
      <li>Supported by the Kernel.</li>
    </ul>
  </li>
</ul>

<h3 id="äº”multithreading-models">äº”ã€Multithreading Models</h3>
<ol>
  <li><strong>Many-to-One</strong>
    <ul>
      <li>Many user-level threads mapped to single kernel thread.</li>
      <li><strong>One thread blocking causes all to block.</strong></li>
      <li>Multiple threads may not run in parallel on muticore system because only one may be in kernel at a time.</li>
      <li>Examplesï¼š<code class="language-plaintext highlighter-rouge">Solaris Green Threads</code>ã€<code class="language-plaintext highlighter-rouge">GNU Portable Threads</code>
<img src="https://i.imgur.com/dwfuxrT.jpg" alt="" /></li>
    </ul>
  </li>
  <li><strong>One-to-One</strong>
    <ul>
      <li>Each user-level thread maps to kernel thread.</li>
      <li><strong>Creating a user-level thread creates a kernel thread.</strong></li>
      <li>More concurrency than many-to-one.</li>
      <li>Number of threads per process sometimes restricted due to overhead.</li>
      <li>Examplesï¼š<code class="language-plaintext highlighter-rouge">Windows NT/XP/2000</code>ã€<code class="language-plaintext highlighter-rouge">Linux</code>ã€<code class="language-plaintext highlighter-rouge">Solaris 9 and later</code>
<img src="https://i.imgur.com/Fh9QH0S.jpg" alt="" /></li>
    </ul>
  </li>
  <li><strong>Many-to-Many</strong>
    <ul>
      <li>Allows many user level threads to be mapped to many kernel threads.</li>
      <li>Allows the operating system to create a sufficient number of kernel threads.</li>
      <li>Solaris prior to version 9.</li>
      <li>Exampleï¼š<code class="language-plaintext highlighter-rouge">Windows NT/2000 with the ThreadFiber package</code>
<img src="https://i.imgur.com/hWCuKOk.jpg" alt="" /></li>
    </ul>
  </li>
  <li><strong>Two-level</strong>
    <ul>
      <li>Similar to M:M, except that it allows a user thread to be bound to kernel thread.</li>
      <li>Examplesï¼š<code class="language-plaintext highlighter-rouge">IRIX</code>ã€<code class="language-plaintext highlighter-rouge">HP-UX</code>ã€<code class="language-plaintext highlighter-rouge">Tru64 UNIX</code>ã€<code class="language-plaintext highlighter-rouge">Solaris 8 and earlier</code>
<img src="https://i.imgur.com/iRt3Xj2.jpg" alt="" /></li>
    </ul>
  </li>
</ol>

<h3 id="å…­pthreads">å…­ã€Pthreads</h3>
<ul>
  <li>May be provided either as user-level or kernel-level.</li>
  <li>A POSIX standard (IEEE 1003.1c) API for thread creation and synchronization.</li>
  <li><strong>Specification, not implementation.</strong></li>
  <li>API specifies behavior of the thread library, implementation is up to development of the library.</li>
  <li>Common in UNIX operating systems (Solaris, Linux, Mac OS X).</li>
</ul>

<h4 id="pthreadh">pthread.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="n">pthread_attr_t</span>
<span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="c1">//create a thread</span>


<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
<span class="c1">//terminate a thread</span>


<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
<span class="c1">//wait for thread termination</span>

</code></pre></div></div>

<h5 id="pthread_create">pthread_create()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
<span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span>
<span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t *thread</code>ï¼šthread çš„è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_attr_t *attr</code>ï¼šthread çš„å±¬æ€§ï¼Œè¨­å®šç‚º NULL è¡¨ç¤ºä½¿ç”¨é è¨­å€¼</li>
  <li><code class="language-plaintext highlighter-rouge">void *(*start_routine)(void*)</code>ï¼šthread è¦åŸ·è¡Œçš„ function</li>
  <li><code class="language-plaintext highlighter-rouge">void *arg</code>ï¼šå‚³éçµ¦ thread çš„åƒæ•¸</li>
</ul>

<h5 id="pthread_exit">pthread_exit()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">void *retval</code>ï¼šthread çµæŸæ™‚å›å‚³çš„è®Šæ•¸</li>
</ul>

<h5 id="pthread_join">pthread_join()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t th</code>ï¼šthread è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">void **thread_return</code>ï¼šæ¥æ”¶ pthread_exit å‚³å›çš„è®Šæ•¸</li>
</ul>

<h3 id="èª²ç¨‹ä½œæ¥­">èª²ç¨‹ä½œæ¥­</h3>
<ul>
  <li>å¾ 1 - 10000 ä¹‹é–“å–å‡ºæ‰€æœ‰çš„è³ªæ•¸ï¼Œåˆ©ç”¨ threads ä¾†åˆ†é…è¨ˆç®—è³ªæ•¸çš„ç¯„åœã€‚</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt; 
#include &lt;time.h&gt;
</span>
<span class="cp">#define NUM_THREADS 10
#define MSIZE 10000
</span>
<span class="c1">// æ‰¾å‡º 1 - 10000 çš„æ‰€æœ‰è³ªæ•¸</span>

<span class="k">static</span> <span class="kt">double</span> <span class="nf">getDoubleTime</span><span class="p">();</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="n">pthread_mutex_t</span> <span class="n">work_mutex</span><span class="p">;</span>

<span class="c1">// å®£å‘Š prime_array é™£åˆ—</span>
<span class="kt">int</span> <span class="n">prime_array</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">][(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">)];</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">pthread_t</span> <span class="n">a_thread</span><span class="p">[</span><span class="n">NUM_THREADS</span><span class="p">];</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">thread_result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lots_of_threads</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">print_prime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="c1">// start to measure time...</span>
	<span class="kt">double</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">getDoubleTime</span><span class="p">();</span>
	
	<span class="c1">// initialize mutex...</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work_mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
       	<span class="n">perror</span><span class="p">(</span><span class="s">"Mutex initialization failed"</span><span class="p">);</span>
	    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

	<span class="c1">// pthread_create...</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lots_of_threads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">a_thread</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">]),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_function</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="kt">long</span><span class="p">)</span><span class="n">lots_of_threads</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">perror</span><span class="p">(</span><span class="s">"Thread creation failed"</span><span class="p">);</span>
        		<span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// pthread_join...</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">lots_of_threads</span> <span class="o">=</span> <span class="n">NUM_THREADS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lots_of_threads</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        	<span class="n">res</span> <span class="o">=</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">a_thread</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">thread_result</span><span class="p">);</span> 

            <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	            <span class="n">perror</span><span class="p">(</span><span class="s">"pthread_join failed"</span><span class="p">);</span>
        	<span class="p">}</span>
    <span class="p">}</span>	
    
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// è¨­å®šè¨ˆæ•¸å™¨</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">lots_of_threads</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">&lt;</span> <span class="n">NUM_THREADS</span><span class="p">;</span> <span class="n">lots_of_threads</span> <span class="o">++</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">The thread[%d]'s numbersï¼š</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lots_of_threads</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prime_array</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">prime_array</span><span class="p">[</span><span class="n">lots_of_threads</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>                        <span class="p">}</span>
    <span class="p">}</span>


	<span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Thread joined</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

	<span class="c1">// stop measuring time...</span>
	<span class="kt">double</span> <span class="n">finish_time</span> <span class="o">=</span> <span class="n">getDoubleTime</span><span class="p">();</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"Execute Time:  %.3lf ms</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">finish_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">));</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">thread_function</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// pthread_mutex_lock(&amp;work_mutex);</span>
	
    <span class="kt">int</span> <span class="n">my_num</span> <span class="o">=</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="c1">// if (MSIZE % NUM_THREADS != 0){    printf("error");   pthread_exit(-1);    }</span>

    <span class="kt">int</span> <span class="n">start_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">)</span> <span class="o">*</span> <span class="n">my_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">MSIZE</span> <span class="o">/</span> <span class="n">NUM_THREADS</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">my_num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// Set the loop</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// Set the counter</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="c1">// result</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"I'm thread[%d], start_num:%d, end_num:%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">my_num</span><span class="p">,</span> <span class="n">start_num</span><span class="p">,</span> <span class="n">end_num</span><span class="p">);</span>

    <span class="cm">/* find the prime number */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_num</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// Reset counter</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> 
            <span class="n">prime_array</span><span class="p">[</span><span class="n">my_num</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">k</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="c1">// pthread_mutex_unlock(&amp;work_mutex);</span>
	<span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">double</span> <span class="nf">getDoubleTime</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tm_tv</span><span class="p">;</span>
        <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm_tv</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(((</span><span class="kt">double</span><span class="p">)</span><span class="n">tm_tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">1000</span><span class="p">.</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">tm_tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>
<ul>
  <li>åŸ·è¡Œçµæœ
<img src="https://i.imgur.com/jw2pSxj.jpg" alt="" /></li>
</ul>

<h2 id="äºŒlinux-ç¨‹å¼è¨­è¨ˆ">äºŒã€Linux ç¨‹å¼è¨­è¨ˆ</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170324/Linux_programming_pthread.pdf">Linux Programming - Pthread</a></li>
    </ul>
  </li>
  <li>åƒè€ƒè³‡æ–™
    <ul>
      <li><a href="https://hackmd.io/s/Skh_AaVix">Toward Concurrency</a></li>
      <li><a href="https://barrgroup.com/Embedded-Systems/How-To/RTOS-Mutex-Semaphore">Mutexes and Semaphores Demystified</a></li>
      <li><a href="https://blog.feabhas.com/2009/09/mutex-vs-semaphores-%E2%80%93-part-1-semaphores/">Mutex vs. Semaphores â€“ Part 1: Semaphores</a></li>
      <li><a href="https://blog.feabhas.com/2009/09/mutex-vs-semaphores-%E2%80%93-part-2-the-mutex/">Mutex vs. Semaphores â€“ Part 2: The Mutex</a></li>
      <li><a href="https://blog.feabhas.com/2009/10/mutex-vs-semaphores-%E2%80%93-part-3-final-part-mutual-exclusion-problems/">Mutex vs. Semaphores â€“ Part 3: Mutual Exclusion Problems</a></li>
    </ul>
  </li>
</ul>

<h3 id="ä¸€pthreads">ä¸€ã€Pthreads</h3>
<ul>
  <li>May be provided either as user-level or kernel-level.</li>
  <li>A POSIX standard (IEEE 1003.1c) API for thread creation and synchronization.</li>
  <li><strong>Specification, not implementation.</strong></li>
  <li>API specifies behavior of the thread library, implementation is up to development of the library.</li>
  <li>Common in UNIX operating systems (Solaris, Linux, Mac OS X).</li>
</ul>

<h4 id="pthreadh-1">pthread.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span> <span class="n">pthread_attr_t</span>
<span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
<span class="c1">//create a thread</span>


<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
<span class="c1">//terminate a thread</span>


<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
<span class="c1">//wait for thread termination</span>


<span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
<span class="c1">//cancel a thread</span>


<span class="kt">int</span> <span class="nf">pthread_setcancelstate</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">oldstate</span><span class="p">);</span>
<span class="c1">//set cancellation state</span>


<span class="kt">int</span> <span class="nf">pthread_setcanceltype</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">oldtype</span><span class="p">);</span>
<span class="c1">//set cancellation type</span>
</code></pre></div></div>

<h5 id="pthread_create-1">pthread_create()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
<span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span>
<span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t *thread</code>ï¼šthread çš„è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_attr_t *attr</code>ï¼šthread çš„å±¬æ€§ï¼Œè¨­å®šç‚º NULL è¡¨ç¤ºä½¿ç”¨é è¨­å€¼</li>
  <li><code class="language-plaintext highlighter-rouge">void *(*start_routine)(void*)</code>ï¼šthread è¦åŸ·è¡Œçš„ function</li>
  <li><code class="language-plaintext highlighter-rouge">void *arg</code>ï¼šå‚³éçµ¦ thread çš„åƒæ•¸</li>
</ul>

<h5 id="pthread_exit-1">pthread_exit()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">retval</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">void *retval</code>ï¼šthread çµæŸæ™‚å›å‚³çš„è®Šæ•¸</li>
</ul>

<h5 id="pthread_join-1">pthread_join()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="n">th</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_t th</code>ï¼šthread è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">void **thread_return</code>ï¼šæ¥æ”¶ pthread_exit å‚³å›çš„è®Šæ•¸</li>
</ul>

<h5 id="pthread_setcancelstate">pthread_setcancelstate()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_setcancelstate</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">oldstate</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">int state</code>ï¼šè¨­å®šç‚º PTHREAD_CANCEL_ENABLE å³è¡¨ç¤ºå…è¨±å–æ¶ˆ thread çš„è«‹æ±‚ï¼›è¨­å®šç‚º PTHREAD_CANCEL_DISABLE å³è¡¨ç¤ºå¿½ç•¥å–æ¶ˆçš„è«‹æ±‚ã€‚</li>
  <li><code class="language-plaintext highlighter-rouge">int *oldstate</code>ï¼šæ­¤æŒ‡æ¨™æŒ‡å‘å‰ä¸€å€‹ç‹€æ…‹</li>
</ul>

<h5 id="pthread_setcanceltype">pthread_setcanceltype()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_setcanceltype</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">oldtype</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">int type</code>ï¼šè¨­å®šç‚º PTHREAD_CANCEL_ASYNCHRONOUS å‰‡ç«‹å³å–æ¶ˆ threadï¼›è¨­å®šç‚º PTHREAD_CANCEL_DEFERRED å‰‡æœƒé‡åˆ°å–æ¶ˆé»æ‰æœƒå–æ¶ˆ threadã€‚
    <ul>
      <li>å–æ¶ˆé»å³æ˜¯ä¸‹åˆ—å‡½æ•¸ï¼š<code class="language-plaintext highlighter-rouge">pthread_join</code>ã€<code class="language-plaintext highlighter-rouge">pthread_cond_wait</code>ã€<code class="language-plaintext highlighter-rouge">pthread_testcancel</code>â€¦ç­‰</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">int *oldtype</code>ï¼šæ­¤æŒ‡æ¨™æŒ‡å‘å‰ä¸€å€‹å‹æ…‹ã€‚</li>
</ul>

<h3 id="äºŒcondition-variables">äºŒã€Condition Variables</h3>
<h4 id="pthread_cond_init-condition-attr">pthread_cond_init (condition, attr)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt">pthread_cond_init</a></li>
</ul>

<h4 id="pthread_cond_destroy-condition">pthread_cond_destroy (condition)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt">pthread_cond_destroy</a></li>
</ul>

<h4 id="pthread_condattr_init-attr">pthread_condattr_init (attr)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt">pthread_condattr_init</a></li>
</ul>

<h4 id="pthread_condattr_destroy-attr">pthread_condattr_destroy (attr)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a></li>
</ul>

<h3 id="ä¸‰thread-synchronization">ä¸‰ã€Thread Synchronization</h3>
<h3 id="1-semaphore">1. Semaphore</h3>
<h4 id="semaphoreh">semaphore.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;semaphore.h&gt;
</span>
<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="c1">//create a semaphore</span>


<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//lock a semaphore</span>


<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//unlock a semaphore</span>


<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//delete a semaphore</span>
</code></pre></div></div>

<h5 id="sem_init">sem_init()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span>
<span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">sem_t *sem</code>ï¼šsemaphore è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">int pshared</code>ï¼šè¨­å®šç‚º 0 è¡¨ç¤ºåƒ…ä¾›ç›®å‰çš„ process åŠå…¶ thread ä½¿ç”¨ã€‚é 0 è¡¨ç¤ºæ­¤ semaphore èˆ‡å…¶ä»– process å…±ç”¨</li>
  <li><code class="language-plaintext highlighter-rouge">unsigned int value</code>ï¼šsemaphore çš„åˆå§‹å€¼</li>
</ul>

<h5 id="sem_wait">sem_wait()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>è‹¥ semaphore ç‚ºé 0ï¼Œå‰‡ semaphore å€¼æ¸›
1ï¼›è‹¥ semaphore ç‚º 0ï¼Œå‰‡å‘¼å«æ­¤ function
çš„ thread æœƒè¢« block ï¼Œç›´åˆ° semaphore å€¼ä¸
ç‚º 0ã€‚</li>
</ul>

<h5 id="sem_post">sem_post()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>å° semaphore å€¼åŠ  1 ã€‚</li>
</ul>

<h5 id="sem_destroy">sem_destroy()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//delete a semaphore</span>
</code></pre></div></div>

<h3 id="2-mutex">2. Mutex</h3>
<h4 id="pthreadh-2">pthread.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">mutexattr</span><span class="p">);</span>
<span class="c1">//create a mutex</span>


<span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//lock a mutex</span>


<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//unlock a mutex</span>


<span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//delete a mutex</span>
</code></pre></div></div>

<h5 id="pthread_mutex_init">pthread_mutex_init()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">mutexattr</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_t *mutex</code>ï¼šmutex è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">const pthread_mutexattr_t *mutexattr</code>ï¼šmutex çš„å±¬æ€§ã€‚è¨­å®šç‚º NULL è¡¨ç¤ºä½¿ç”¨é è¨­ã€‚</li>
</ul>

<h5 id="pthread_mutex_lock">pthread_mutex_lock()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//lock a mutex</span>
</code></pre></div></div>

<h5 id="pthread_mutex_unlock">pthread_mutex_unlock()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//unlock a mutex</span>
</code></pre></div></div>

<h5 id="pthread_mutex_destroy">pthread_mutex_destroy()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//delete a mutex</span>
</code></pre></div></div>

<h3 id="èª²ç¨‹ä½œæ¥­-1">èª²ç¨‹ä½œæ¥­</h3>
<ul>
  <li>Producer - Consumer
```c
/*</li>
  <li>Solution to Producer Consumer Problem</li>
  <li>Using Ptheads, a mutex and condition variables</li>
  <li>From Tanenbaum, Modern Operating Systems, 3rd Ed.
 */</li>
</ul>

<p>/*
    In this version the buffer is a single number.
    The producer is putting numbers into the shared buffer
    (in this case sequentially)
    And the consumer is taking them out.
    If the buffer contains zero, that indicates that the buffer is empty.
    Any other value is valid.
*/</p>

<p>#include <stdio.h>
#include <pthread.h></pthread.h></stdio.h></p>

<p>#define MAX 10   /* Numbers to produce */
#define buf_max 5</p>

<p>pthread_mutex_t the_mutex;
pthread_cond_t condc, condp;
int buffer[5];
int in = 0;
int count = 0;</p>

<p>void *producer(void *ptr) {
    int i = 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i = 1; i &lt;= MAX; i++) {
    pthread_mutex_lock(&amp;the_mutex);	    /* protect buffer */
    while (count == buf_max)    /* If there is something in the buffer then wait */
        pthread_cond_wait(&amp;condp, &amp;the_mutex);

    in++;
    buffer[in] = i;
    printf("ProBuffer[%d]ï¼š%2d\n", in, buffer[in]);
    count++;

    pthread_cond_signal(&amp;condc);	    /* wake up consumer */
    pthread_mutex_unlock(&amp;the_mutex);	/* release the buffer */
}
pthread_exit(0); }
</code></pre></div></div>

<p>void *consumer(void *ptr) {
    int i = 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (i = 1; i &lt;= MAX; i++) {
    pthread_mutex_lock(&amp;the_mutex);	    /* protect buffer */
    while (count == 0)			    /* If there is nothing in the buffer then wait */
        pthread_cond_wait(&amp;condc, &amp;the_mutex);
    
    printf("ConBuffer[%d]ï¼š%2d\n", in, buffer[in]);
    buffer[in] = 0;
    in--;
    count--;
    pthread_cond_signal(&amp;condp);	    /* wake up consumer */

    pthread_mutex_unlock(&amp;the_mutex);	/* release the buffer */
}
pthread_exit(0); }
</code></pre></div></div>

<p>int main(int argc, char **argv) {
    pthread_t pro, con;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Initialize the mutex and condition variables
/* What's the NULL for ??? */
pthread_mutex_init(&amp;the_mutex, NULL);	
pthread_cond_init(&amp;condc, NULL);		/* Initialize consumer condition variable */
pthread_cond_init(&amp;condp, NULL);		/* Initialize producer condition variable */

// Create the threads
pthread_create(&amp;con, NULL, consumer, NULL);
pthread_create(&amp;pro, NULL, producer, NULL);

// Wait for the threads to finish
// Otherwise main might run to the end
// and kill the entire process when it exits.
pthread_join(con, NULL);
pthread_join(pro, NULL);

// Cleanup -- would happen automatically at end of program
pthread_mutex_destroy(&amp;the_mutex);	/* Free up the_mutex */
pthread_cond_destroy(&amp;condc);		/* Free up consumer condition variable */
pthread_cond_destroy(&amp;condp);		/* Free up producer condition variable */ } ``` * åŸ·è¡Œçµæœ ![](https://i.imgur.com/OCVTU3V.jpg)
</code></pre></div></div>
:ET