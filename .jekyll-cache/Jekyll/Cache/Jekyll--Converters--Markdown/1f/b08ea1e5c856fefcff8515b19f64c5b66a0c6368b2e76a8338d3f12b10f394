I"£Ö<ul id="markdown-toc">
  <li><a href="#ä¸€ä½œæ¥­ç³»çµ±" id="markdown-toc-ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</a>    <ul>
      <li><a href="#ä¸€-thread-synchronization" id="markdown-toc-ä¸€-thread-synchronization">(ä¸€) Thread Synchronization</a></li>
      <li><a href="#1-semaphore" id="markdown-toc-1-semaphore">1. Semaphore</a>        <ul>
          <li><a href="#semaphoreh" id="markdown-toc-semaphoreh">semaphore.h</a>            <ul>
              <li><a href="#sem_init" id="markdown-toc-sem_init">sem_init()</a></li>
              <li><a href="#sem_wait" id="markdown-toc-sem_wait">sem_wait()</a></li>
              <li><a href="#sem_post" id="markdown-toc-sem_post">sem_post()</a></li>
              <li><a href="#sem_destroy" id="markdown-toc-sem_destroy">sem_destroy()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#2-mutex" id="markdown-toc-2-mutex">2. Mutex</a>        <ul>
          <li><a href="#pthreadh" id="markdown-toc-pthreadh">pthread.h</a>            <ul>
              <li><a href="#pthread_mutex_init" id="markdown-toc-pthread_mutex_init">pthread_mutex_init()</a></li>
              <li><a href="#pthread_mutex_lock" id="markdown-toc-pthread_mutex_lock">pthread_mutex_lock()</a></li>
              <li><a href="#pthread_mutex_unlock" id="markdown-toc-pthread_mutex_unlock">pthread_mutex_unlock()</a></li>
              <li><a href="#pthread_mutex_destroy" id="markdown-toc-pthread_mutex_destroy">pthread_mutex_destroy()</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#3-condition-variables" id="markdown-toc-3-condition-variables">3. Condition Variables</a>        <ul>
          <li><a href="#pthread_cond_init-condition-attr" id="markdown-toc-pthread_cond_init-condition-attr">pthread_cond_init (condition, attr)</a></li>
          <li><a href="#pthread_cond_destroy-condition" id="markdown-toc-pthread_cond_destroy-condition">pthread_cond_destroy (condition)</a></li>
          <li><a href="#pthread_condattr_init-attr" id="markdown-toc-pthread_condattr_init-attr">pthread_condattr_init (attr)</a></li>
          <li><a href="#pthread_condattr_destroy-attr" id="markdown-toc-pthread_condattr_destroy-attr">pthread_condattr_destroy (attr)</a></li>
        </ul>
      </li>
      <li><a href="#4-barrier" id="markdown-toc-4-barrier">4. Barrier</a></li>
      <li><a href="#äºŒ-producer-consumer-problem" id="markdown-toc-äºŒ-producer-consumer-problem">(äºŒ) Producer-Consumer Problem</a>        <ul>
          <li><a href="#1-producer" id="markdown-toc-1-producer">1. Producer</a></li>
          <li><a href="#2-consumer" id="markdown-toc-2-consumer">2. Consumer</a></li>
        </ul>
      </li>
      <li><a href="#èª²ç¨‹ä½œæ¥­" id="markdown-toc-èª²ç¨‹ä½œæ¥­">èª²ç¨‹ä½œæ¥­</a></li>
    </ul>
  </li>
  <li><a href="#äºŒlinux-ç¨‹å¼è¨­è¨ˆ" id="markdown-toc-äºŒlinux-ç¨‹å¼è¨­è¨ˆ">äºŒã€Linux ç¨‹å¼è¨­è¨ˆ</a>    <ul>
      <li><a href="#socket-programming" id="markdown-toc-socket-programming">Socket Programming</a>        <ul>
          <li><a href="#1-what-is-a-socket" id="markdown-toc-1-what-is-a-socket">1. What is a socketï¼Ÿ</a></li>
          <li><a href="#2-two-essential-types-of-sockets" id="markdown-toc-2-two-essential-types-of-sockets">2. Two essential types of sockets</a></li>
          <li><a href="#1-sock_stream" id="markdown-toc-1-sock_stream">(1) SOCK_STREAM</a></li>
          <li><a href="#2-sock_dgram" id="markdown-toc-2-sock_dgram">(2) SOCK_DGRAM</a></li>
          <li><a href="#example" id="markdown-toc-example">Example</a></li>
        </ul>
      </li>
      <li><a href="#èª²ç¨‹ä½œæ¥­-1" id="markdown-toc-èª²ç¨‹ä½œæ¥­-1">èª²ç¨‹ä½œæ¥­</a></li>
    </ul>
  </li>
</ul>

<h2 id="ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170330/ch04.pdf">Chapter 4: Mutithread Programming</a></li>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170330/ch05.pdf">Chapter 5: Process Scheduling</a></li>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170330/Linux_programming_pthread.pdf">Linux_programming_pthread</a></li>
    </ul>
  </li>
  <li>åƒè€ƒè³‡æ–™
    <ul>
      <li><a href="https://hackmd.io/s/Skh_AaVix">Toward Concurrency</a></li>
      <li><a href="http://tuxthink.blogspot.tw/2013/01/using-condition-variables-in-pthreads.html">Using condition variables in pthreads</a></li>
    </ul>
  </li>
</ul>

<h3 id="ä¸€-thread-synchronization">(ä¸€) Thread Synchronization</h3>
<h3 id="1-semaphore">1. Semaphore</h3>
<h4 id="semaphoreh">semaphore.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;semaphore.h&gt;
</span>
<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="c1">//create a semaphore</span>


<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//lock a semaphore</span>


<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//unlock a semaphore</span>


<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//delete a semaphore</span>
</code></pre></div></div>

<h5 id="sem_init">sem_init()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span>
<span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">sem_t *sem</code>ï¼šsemaphore è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">int pshared</code>ï¼šè¨­å®šç‚º 0 è¡¨ç¤ºåƒ…ä¾›ç›®å‰çš„ process åŠå…¶ thread ä½¿ç”¨ã€‚é 0 è¡¨ç¤ºæ­¤ semaphore èˆ‡å…¶ä»– process å…±ç”¨</li>
  <li><code class="language-plaintext highlighter-rouge">unsigned int value</code>ï¼šsemaphore çš„åˆå§‹å€¼</li>
</ul>

<h5 id="sem_wait">sem_wait()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>è‹¥ semaphore ç‚ºé 0ï¼Œå‰‡ semaphore å€¼æ¸›
1ï¼›è‹¥ semaphore ç‚º 0ï¼Œå‰‡å‘¼å«æ­¤ function
çš„ thread æœƒè¢« block ï¼Œç›´åˆ° semaphore å€¼ä¸
ç‚º 0ã€‚</li>
</ul>

<h5 id="sem_post">sem_post()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>å° semaphore å€¼åŠ  1 ã€‚</li>
</ul>

<h5 id="sem_destroy">sem_destroy()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="c1">//delete a semaphore</span>
</code></pre></div></div>

<h3 id="2-mutex">2. Mutex</h3>
<h4 id="pthreadh">pthread.h</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pthread.h&gt;
</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">mutexattr</span><span class="p">);</span>
<span class="c1">//create a mutex</span>


<span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//lock a mutex</span>


<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//unlock a mutex</span>


<span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//delete a mutex</span>
</code></pre></div></div>

<h5 id="pthread_mutex_init">pthread_mutex_init()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_mutexattr_t</span> <span class="o">*</span><span class="n">mutexattr</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_t *mutex</code>ï¼šmutex è­˜åˆ¥å­—</li>
  <li><code class="language-plaintext highlighter-rouge">const pthread_mutexattr_t *mutexattr</code>ï¼šmutex çš„å±¬æ€§ã€‚è¨­å®šç‚º NULL è¡¨ç¤ºä½¿ç”¨é è¨­ã€‚</li>
</ul>

<h5 id="pthread_mutex_lock">pthread_mutex_lock()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//lock a mutex</span>
</code></pre></div></div>

<h5 id="pthread_mutex_unlock">pthread_mutex_unlock()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//unlock a mutex</span>
</code></pre></div></div>

<h5 id="pthread_mutex_destroy">pthread_mutex_destroy()</h5>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="c1">//delete a mutex</span>
</code></pre></div></div>

<h3 id="3-condition-variables">3. Condition Variables</h3>
<h4 id="pthread_cond_init-condition-attr">pthread_cond_init (condition, attr)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_init.txt">pthread_cond_init</a></li>
</ul>

<h4 id="pthread_cond_destroy-condition">pthread_cond_destroy (condition)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_cond_destroy.txt">pthread_cond_destroy</a></li>
</ul>

<h4 id="pthread_condattr_init-attr">pthread_condattr_init (attr)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_init.txt">pthread_condattr_init</a></li>
</ul>

<h4 id="pthread_condattr_destroy-attr">pthread_condattr_destroy (attr)</h4>
<ul>
  <li><a href="https://computing.llnl.gov/tutorials/pthreads/man/pthread_condattr_destroy.txt">pthread_condattr_destroy</a></li>
</ul>

<h3 id="4-barrier">4. Barrier</h3>
<ul>
  <li><a href="http://angelonotes.blogspot.tw/2012/02/pthreadbarrier.html">Using barriers in pthreads</a></li>
  <li><a href="http://angelonotes.blogspot.tw/2012/02/pthreadbarrier.html">pthreadï¸°barrier</a></li>
</ul>

<h3 id="äºŒ-producer-consumer-problem">(äºŒ) Producer-Consumer Problem</h3>
<h4 id="1-producer">1. Producer</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">item</span> <span class="n">next</span> <span class="n">produced</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* produce an item in next produced */</span>
    
    <span class="k">while</span> <span class="p">(((</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER</span> <span class="n">SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span>
    <span class="p">;</span> <span class="cm">/* do nothing */</span>
        
    <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span> <span class="n">produced</span><span class="p">;</span>
    <span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER</span> <span class="n">SIZE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="2-consumer">2. Consumer</h4>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">item</span> <span class="n">next</span> <span class="n">consumed</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span>
    <span class="p">;</span> <span class="cm">/* do nothing */</span>
    
    <span class="n">next</span> <span class="n">consumed</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER</span> <span class="n">SIZE</span><span class="p">;</span>
    
    <span class="cm">/* consume the item in next consumed */</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èª²ç¨‹ä½œæ¥­">èª²ç¨‹ä½œæ¥­</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 *  Solution to Producer Consumer Problem
 *  Using Ptheads, a mutex and condition variables
 *  From Tanenbaum, Modern Operating Systems, 3rd Ed.
 */</span>

<span class="cm">/*
    In this version the buffer is a single number.
    The producer is putting numbers into the shared buffer
    (in this case sequentially)
    And the consumer is taking them out.
    If the buffer contains zero, that indicates that the buffer is empty.
    Any other value is valid.
*/</span>

<span class="cp">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
</span>
<span class="cp">#define MAX 10//000000			</span><span class="cm">/* Numbers to produce */</span><span class="cp">
#define BUFFER_SIZE 5
</span>
<span class="n">pthread_mutex_t</span> <span class="n">the_mutex</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">condc</span><span class="p">,</span> <span class="n">condp</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">producer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>	<span class="cm">/* protect buffer */</span>
        
        <span class="k">while</span> <span class="p">(((</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span>		       <span class="cm">/* If there is something in the buffer then wait */</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>

        <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"ProBuffer[%d]ï¼š%2d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]);</span>
        <span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
   
        <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">);</span>	<span class="cm">/* wake up consumer */</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>	<span class="cm">/* release the buffer */</span>
    <span class="p">}</span>

    <span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="o">*</span><span class="nf">consumer</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>	<span class="cm">/* protect buffer */</span>
    
        <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span>			<span class="cm">/* If there is nothing in the buffer then wait */</span>
            <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>
    
        <span class="n">printf</span><span class="p">(</span><span class="s">"ConBuffer[%d]ï¼š%2d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">]);</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span>
        <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
        <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">);</span>	<span class="cm">/* wake up consumer */</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>	<span class="cm">/* release the buffer */</span>
    <span class="p">}</span>
    <span class="n">pthread_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">pro</span><span class="p">,</span> <span class="n">con</span><span class="p">;</span>

    <span class="c1">// Initialize the mutex and condition variables</span>
    <span class="cm">/* What's the NULL for ??? */</span>
    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>	
    <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>		<span class="cm">/* Initialize consumer condition variable */</span>
    <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>		<span class="cm">/* Initialize producer condition variable */</span>

    <span class="c1">// Create the threads</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">con</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consumer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pro</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Wait for the threads to finish</span>
    <span class="c1">// Otherwise main might run to the end</span>
    <span class="c1">// and kill the entire process when it exits.</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">con</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">pro</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// Cleanup -- would happen automatically at end of program</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">the_mutex</span><span class="p">);</span>	<span class="cm">/* Free up the_mutex */</span>
    <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condc</span><span class="p">);</span>		<span class="cm">/* Free up consumer condition variable */</span>
    <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">condp</span><span class="p">);</span>		<span class="cm">/* Free up producer condition variable */</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>åŸ·è¡Œçµæœ
<img src="https://i.imgur.com/6miNt1O.jpg" alt="" /></li>
</ul>

<h2 id="äºŒlinux-ç¨‹å¼è¨­è¨ˆ">äºŒã€Linux ç¨‹å¼è¨­è¨ˆ</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170331/Socket_Programming.pdf">Socket_Programming</a></li>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170331/Linux-Programming_Socket_1.pdf">Linux-Programming_Socket_1</a></li>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170331/Linux-Programming_Socket_2.pdf">Linux-Programming_Socket_2</a></li>
    </ul>
  </li>
</ul>

<h3 id="socket-programming">Socket Programming</h3>
<h4 id="1-what-is-a-socket">1. What is a socketï¼Ÿ</h4>
<ul>
  <li>An interface between application and network.
    <ul>
      <li>The application creates a socket.</li>
      <li>The socket type dictates the style of communication.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">reliable</code> vs. <code class="language-plaintext highlighter-rouge">best effort</code></li>
          <li><code class="language-plaintext highlighter-rouge">connection-oriented</code> vs. <code class="language-plaintext highlighter-rouge">connectionless</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Once configured the application can
    <ul>
      <li>pass data to the socket for network transmission</li>
      <li>receive data from the socket (transmitted through the network by some other host)</li>
    </ul>
  </li>
</ul>

<h4 id="2-two-essential-types-of-sockets">2. Two essential types of sockets</h4>
<p><img src="https://i.imgur.com/HMu29e3.jpg" alt="" /></p>

<h4 id="1-sock_stream">(1) SOCK_STREAM</h4>
<ul>
  <li>a.k.a. TCP</li>
  <li>reliable delivery</li>
  <li>in-order guaranteed</li>
  <li>connection-oriented</li>
  <li>bidirectional</li>
</ul>

<h4 id="2-sock_dgram">(2) SOCK_DGRAM</h4>
<ul>
  <li>a.k.a. UDP</li>
  <li>unreliable delivery</li>
  <li>no order guarantees</li>
  <li>no notion of â€œconnectionâ€ â€“ app indicates dest. for each packet</li>
  <li>can send or receive</li>
</ul>

<h4 id="example">Example</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">server</code> éƒ¨ä»½</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*  Make the necessary includes and set up the variables.  */</span>

<span class="cp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">server_sockfd</span><span class="p">,</span> <span class="n">client_sockfd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">server_len</span><span class="p">,</span> <span class="n">client_len</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_address</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client_address</span><span class="p">;</span>

<span class="cm">/*  Create an unnamed socket for the server.  */</span>

    <span class="n">server_sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/*  Name the socket.  */</span>

    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">9734</span><span class="p">;</span>
    <span class="n">server_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_address</span><span class="p">);</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_address</span><span class="p">,</span> <span class="n">server_len</span><span class="p">);</span>

<span class="cm">/*  Create a connection queue and wait for clients.  */</span>

    <span class="n">listen</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">"server waiting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="cm">/*  Accept a connection.  */</span>

        <span class="n">client_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_address</span><span class="p">);</span>
        <span class="n">client_sockfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> 
            <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_len</span><span class="p">);</span>

<span class="cm">/*  We can now read/write to client on client_sockfd.  */</span>

        <span class="n">read</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"receive from client = %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
        <span class="n">ch</span><span class="o">++</span><span class="p">;</span>
        <span class="n">write</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">client</code> éƒ¨ä»½</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*  Make the necessary includes and set up the variables.  */</span>

<span class="cp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>

<span class="cm">/*  Create a socket for the client.  */</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/*  Name the socket, as agreed with the server.  */</span>

    <span class="n">address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">9734</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

<span class="cm">/*  Now connect our socket to the server's socket.  */</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"oops: client2"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cm">/*  We can now read/write via sockfd.  */</span>

    <span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"char from server = %c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="èª²ç¨‹ä½œæ¥­-1">èª²ç¨‹ä½œæ¥­</h3>
<ul>
  <li>
    <p>åˆ©ç”¨Socket Programmingï¼Œå°‡ client ç«¯çš„æ•´æ•¸é™£åˆ—å‚³é€çµ¦ server ç«¯æ’åºï¼Œä¸¦å°‡æ’åºå¾Œçš„çµæœå›å‚³çµ¦ client ç«¯é¡¯ç¤ºã€‚</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">server</code> éƒ¨ä»½</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*  Make the necessary includes and set up the variables.  */</span>

<span class="cp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">server_sockfd</span><span class="p">,</span> <span class="n">client_sockfd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">server_len</span><span class="p">,</span> <span class="n">client_len</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_address</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">client_address</span><span class="p">;</span>

<span class="cm">/*  Create an unnamed socket for the server.  */</span>

    <span class="n">server_sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/*  Name the socket.  */</span>

    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">server_address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">9734</span><span class="p">;</span>
    <span class="n">server_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_address</span><span class="p">);</span>
    <span class="n">bind</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_address</span><span class="p">,</span> <span class="n">server_len</span><span class="p">);</span>

<span class="cm">/*  Create a connection queue and wait for clients.  */</span>

    <span class="n">listen</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>    
    
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">server waiting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

<span class="cm">/*  Accept a connection.  */</span>

        <span class="n">client_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">client_address</span><span class="p">);</span>
        <span class="n">client_sockfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">server_sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">client_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">client_len</span><span class="p">);</span>

<span class="cm">/*  We can now read/write to client on client_sockfd.  */</span>

        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">get_n</span><span class="p">;</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
        
        <span class="n">read</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">get_n</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">get_n</span><span class="p">));</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="n">get_n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="n">read</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">get_n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"sort arr[%d] from client:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">get_n</span><span class="p">);</span>
     
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">get_n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                    <span class="n">buf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
 
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">get_n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"arr[%d] = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        
        <span class="n">write</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">get_n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
        <span class="n">close</span><span class="p">(</span><span class="n">client_sockfd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">client</code> éƒ¨ä»½</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*  Make the necessary includes and set up the variables.  */</span>

<span class="cp">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="cp">#define SIZE 5
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sockfd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

<span class="cm">/*  Create a socket for the client.  */</span>

    <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/*  Name the socket, as agreed with the server.  */</span>

    <span class="n">address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"127.0.0.1"</span><span class="p">);</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="mi">9734</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>

<span class="cm">/*  Now connect our socket to the server's socket.  */</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">perror</span><span class="p">(</span><span class="s">"oops: client!"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

<span class="cm">/*  We can now read/write via sockfd.  */</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">SIZE</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">rec</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">original from client - arr[]</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span> 
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    	<span class="n">printf</span><span class="p">(</span><span class="s">"arr[%d] = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="n">write</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span>
   
   
    <span class="n">read</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">rec</span><span class="p">,</span> <span class="n">SIZE</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rec</span><span class="p">));</span>    
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">result from server - rec[]</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"rec[%d] = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">rec</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> 
    

    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>åŸ·è¡Œçµæœ
<img src="https://i.imgur.com/AhJZRLN.jpg" alt="" /></li>
</ul>
:ET