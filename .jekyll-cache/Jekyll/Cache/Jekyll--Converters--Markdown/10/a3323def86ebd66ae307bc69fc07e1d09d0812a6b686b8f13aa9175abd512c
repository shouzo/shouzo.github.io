I"ÆO<ul id="markdown-toc">
  <li><a href="#ä¸€ä½œæ¥­ç³»çµ±" id="markdown-toc-ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</a>    <ul>
      <li><a href="#race-condition" id="markdown-toc-race-condition">Race Condition</a></li>
      <li><a href="#ä¸€-critical-section-problem" id="markdown-toc-ä¸€-critical-section-problem">(ä¸€) Critical-Section Problem</a></li>
      <li><a href="#äºŒ-solution-to-critical-section-problem" id="markdown-toc-äºŒ-solution-to-critical-section-problem">(äºŒ) Solution to Critical-Section Problem</a></li>
      <li><a href="#ä¸‰-petersons-solution" id="markdown-toc-ä¸‰-petersons-solution">(ä¸‰) Petersonâ€™s Solution</a></li>
      <li><a href="#å››-synchronization-hardware" id="markdown-toc-å››-synchronization-hardware">(å››) Synchronization Hardware</a>        <ul>
          <li><a href="#1-test_and_set-instruction" id="markdown-toc-1-test_and_set-instruction">1. test_and_set Instruction</a></li>
          <li><a href="#2-compare_and_swap-instruction" id="markdown-toc-2-compare_and_swap-instruction">2. compare_and_swap Instruction</a></li>
        </ul>
      </li>
      <li><a href="#äº”-mutex-locks" id="markdown-toc-äº”-mutex-locks">(äº”) Mutex Locks</a>        <ul>
          <li><a href="#acquire-and-release" id="markdown-toc-acquire-and-release">acquire() and release()</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#äºŒlinux-ç¨‹å¼è¨­è¨ˆ" id="markdown-toc-äºŒlinux-ç¨‹å¼è¨­è¨ˆ">äºŒã€Linux ç¨‹å¼è¨­è¨ˆ</a>    <ul>
      <li><a href="#ä¸€-low-level-file-access" id="markdown-toc-ä¸€-low-level-file-access">(ä¸€) Low-level file access</a>        <ul>
          <li><a href="#1-open" id="markdown-toc-1-open">1. open</a></li>
          <li><a href="#2-read" id="markdown-toc-2-read">2. read</a></li>
          <li><a href="#3-write" id="markdown-toc-3-write">3. write</a></li>
          <li><a href="#example-file-copy" id="markdown-toc-example-file-copy">[Example] File copy</a></li>
        </ul>
      </li>
      <li><a href="#äºŒ-standard-io-library" id="markdown-toc-äºŒ-standard-io-library">(äºŒ) Standard I/O Library</a>        <ul>
          <li><a href="#fopen" id="markdown-toc-fopen">fopen</a></li>
          <li><a href="#2-printf-sprintf-fprintf" id="markdown-toc-2-printf-sprintf-fprintf">2. printf, sprintf, fprintf</a></li>
          <li><a href="#3-scanf-fscanf-sscanf" id="markdown-toc-3-scanf-fscanf-sscanf">3. scanf, fscanf, sscanf</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="ä¸€ä½œæ¥­ç³»çµ±">ä¸€ã€ä½œæ¥­ç³»çµ±</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="https://github.com/shouzo/Operating-System_pages/blob/master/class-tutorial/20170427/ch06.pdf">Chapter 6: Process Scheduling</a></li>
    </ul>
  </li>
</ul>

<h3 id="race-condition">Race Condition</h3>
<ul>
  <li>
    <p>Consumer
<img src="https://i.imgur.com/07kx1WD.jpg" alt="" /></p>
  </li>
  <li>
    <p>Producer
<img src="https://i.imgur.com/eBPWPyb.jpg" alt="" /></p>
  </li>
  <li>
    <p>Race Condition
<img src="https://i.imgur.com/Q5qf9Xi.jpg" alt="" /></p>
  </li>
</ul>

<h3 id="ä¸€-critical-section-problem">(ä¸€) Critical-Section Problem</h3>
<ul>
  <li>General Structureï¼š
<img src="https://i.imgur.com/yVVaplo.jpg" alt="" />
<img src="https://i.imgur.com/dWa1ujd.jpg" alt="" /></li>
</ul>

<h3 id="äºŒ-solution-to-critical-section-problem">(äºŒ) Solution to Critical-Section Problem</h3>
<ol>
  <li>
    <p><strong>Mutual Exclusion</strong> - If process Pi is executing in its critical section, then no other processes can be executing in their critical sections.</p>
  </li>
  <li>
    <p><strong>Progress</strong> - If no process is executing in its critical section and there exist some processes that wish to enter their critical section, then the selection of the processes that will enter the critical section next cannot be postponed indefinitely.</p>
  </li>
  <li><strong>Bounded Waiting</strong> - A bound must exist on the number of times that other processes are allowed to enter their critical sections.
    <ul>
      <li>Assume that each process executes at a nonzero speed.</li>
      <li>No assumption concerning relative speed of the n processes.</li>
    </ul>
  </li>
  <li>Two approaches depending on if kernel is preemptive or non-preemptive.
    <ul>
      <li><strong>Preemptive</strong> â€“ allows preemption of process when running in kernel mode.</li>
      <li><strong>Non-preemptive</strong> â€“ runs until exits kernel mode, blocks, or voluntarily yields CPU.
        <ul>
          <li>Essentially free of race conditions in kernel mode.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h3 id="ä¸‰-petersons-solution">(ä¸‰) Petersonâ€™s Solution</h3>
<ul>
  <li>Good algorithmic description of solving the problem.</li>
  <li>Two process solution</li>
  <li>Assume that the load and store instructions are atomic; that is, cannot be interrupted</li>
  <li>The two processes share two variablesï¼š
    <ul>
      <li>int turn;</li>
      <li>Boolean flag[2]</li>
    </ul>
  </li>
  <li>The variable turn indicates whose turn it is to enter the critical section</li>
  <li>The flag array is used to indicate if a process is ready to enter the critical section.</li>
  <li><code class="language-plaintext highlighter-rouge">flag[i] = true</code> implies that process Pi is ready!</li>
</ul>

<p><img src="https://i.imgur.com/VjV8Owl.jpg" alt="" /></p>

<ul>
  <li>Provable that
    <ol>
      <li>Mutual exclusion is preserved.</li>
      <li>Progress requirement is satisfied.</li>
      <li>Bounded-waiting requirement is met.</li>
    </ol>
  </li>
</ul>

<h3 id="å››-synchronization-hardware">(å››) Synchronization Hardware</h3>
<ul>
  <li>Many systems provide hardware support for critical section code.</li>
  <li>All solutions below based on idea of <strong>locking</strong>.
    <ul>
      <li>Protecting critical regions via locks.</li>
    </ul>
  </li>
  <li>Uniprocessors â€“ could disable interrupts
    <ul>
      <li>Currently running code would execute without preemption.</li>
      <li>Generally too inefficient on multiprocessor systems.
        <ul>
          <li>Operating systems using this not broadly scalable.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Modern machines provide special atomic hardware instructions.
    <ul>
      <li><strong>Atomic</strong> = non-interruptible
        <ul>
          <li>Either test memory word and set value.</li>
          <li>Or swap contents of two memory words.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="1-test_and_set-instruction">1. test_and_set Instruction</h4>
<p><img src="https://i.imgur.com/HP1PMeH.jpg" alt="" /></p>

<ul>
  <li>
    <p>Solution using test_and_set()
  <img src="https://i.imgur.com/5SMn8ix.jpg" alt="" /></p>
  </li>
  <li>
    <p>Bounded-waiting Mutual Exclusion with test_and_set
  <img src="https://i.imgur.com/wGOMFdV.jpg" alt="" /></p>
  </li>
</ul>

<h4 id="2-compare_and_swap-instruction">2. compare_and_swap Instruction</h4>
<p><img src="https://i.imgur.com/7neEbLe.jpg" alt="" /></p>

<ul>
  <li>Solution using compare_and_swap
  <img src="https://i.imgur.com/37TZRjA.jpg" alt="" /></li>
</ul>

<h3 id="äº”-mutex-locks">(äº”) Mutex Locks</h3>
<ul>
  <li>Previous solutions are complicated and generally inaccessible to application programmers.</li>
  <li>OS designers build software tools to solve critical section problem.</li>
  <li>Simplest is mutex lock</li>
  <li>Product critical regions with it by first <strong>acquire()</strong> a lock then <strong>release()</strong> it.
    <ul>
      <li>Boolean variable indicating if lock is available or not</li>
    </ul>
  </li>
  <li>Calls to <strong>acquire()</strong> and <strong>release()</strong> must be atomic.
    <ul>
      <li>Usually implemented via hardware atomic instructions</li>
    </ul>
  </li>
  <li>But this solution requires <strong>busy waiting</strong>.
    <ul>
      <li>This lock therefore called a <strong>spinlock</strong></li>
    </ul>
  </li>
</ul>

<h4 id="acquire-and-release">acquire() and release()</h4>
<p><img src="https://i.imgur.com/stNKbbR.jpg" alt="" /></p>

<h2 id="äºŒlinux-ç¨‹å¼è¨­è¨ˆ">äºŒã€Linux ç¨‹å¼è¨­è¨ˆ</h2>
<ul>
  <li>èª²ç¨‹ç°¡å ±
    <ul>
      <li><a href="">Working with Files</a></li>
      <li><a href="http://advancedlinuxprogramming.com/alp-folder/alp-apB-low-level-io.pdf">Low-Level I/O</a></li>
    </ul>
  </li>
</ul>

<h3 id="ä¸€-low-level-file-access">(ä¸€) Low-level file access</h3>
<p>Headerï¼š<code class="language-plaintext highlighter-rouge">#include &lt;unistd.h&gt;</code></p>

<ul>
  <li>Action
    <ul>
      <li>open</li>
      <li>read</li>
      <li>write</li>
      <li>close</li>
      <li>ioctl</li>
    </ul>
  </li>
  <li>Status
    <ul>
      <li>0ï¼šstandard input</li>
      <li>1ï¼šstandard output</li>
      <li>2ï¼šstandard error</li>
    </ul>
  </li>
  <li>Permission
    <ul>
      <li>S_IRUSR</li>
      <li>S_IWUSR</li>
      <li>S_IXUSR</li>
      <li>S_IRGRP</li>
      <li>S_IWGRP</li>
      <li>S_IWGRP</li>
      <li>S_IROTH</li>
      <li>S_IWOTH</li>
      <li>S_IXOTH</li>
    </ul>
  </li>
</ul>

<h4 id="1-open">1. open</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">int open(const char* path, int oflags);</code></li>
  <li><code class="language-plaintext highlighter-rouge">int open(const char* path, int oflags, mode_t mode);</code></li>
  <li>Mode
    <ul>
      <li>O_RDONLY</li>
      <li>O_WRONLY</li>
      <li>O_RDWR</li>
    </ul>
  </li>
  <li>Oflags
    <ul>
      <li>O_APPEND</li>
      <li>O_TRUNC ( æ”¾æ£„ç¾æœ‰çš„å…§å®¹ã€é•·åº¦æ­¸é›¶)</li>
      <li>O_CREAT</li>
      <li>O_EXCL (ç¢ºä¿å‘¼å«è€…å¯ä»¥ç”¢ç”Ÿæª”æ¡ˆ)</li>
    </ul>
  </li>
</ul>

<h4 id="2-read">2. read</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">size_t read(int fildes, void* buf, size_t nbytes);</code></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>
    
    <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"A read error has occurred</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">26</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">nread</span><span class="p">))</span> <span class="o">!=</span> <span class="n">nread</span><span class="p">)</span>
        <span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"A write error has occurred</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
        
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="3-write">3. write</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">size_t write(int fildes, void* buf, size_t n
bytes);</code></li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Here is some data</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">18</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">18</span>
<span class="p">)</span>
    <span class="n">write</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"A write error has occurred on file descriptor 1</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mi">46</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="example-file-copy">[Example] File copy</h4>
<ul>
  <li>Example 1</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>
    
    <span class="n">in</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"file.in"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"file.out"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_CREAT</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">write</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
        
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>Example2</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">block</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>
    
    <span class="n">in</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"file.in"</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"file.out"</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="o">|</span><span class="n">O_CREAT</span><span class="p">,</span> <span class="n">S_IRUSR</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
    <span class="k">while</span><span class="p">((</span><span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="n">block</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">block</span><span class="p">)))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">write</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">block</span><span class="p">,</span><span class="n">nread</span><span class="p">);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="äºŒ-standard-io-library">(äºŒ) Standard I/O Library</h3>
<p>Headerï¼š<code class="language-plaintext highlighter-rouge">#include &lt;stdio.h&gt;</code></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">fopen</code>, <code class="language-plaintext highlighter-rouge">fclose</code>
    <ul>
      <li>int fclose(FILE* stream);</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fread</code>, <code class="language-plaintext highlighter-rouge">fwrite</code>
    <ul>
      <li>size_t fread(void* ptr, size_t size, size_t nitems, FILE* stream);</li>
      <li>size_t fwrite(void* ptr, size_t size, size_t nitems, FILE* stream);</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fflush</code>
    <ul>
      <li>int fflush(FLIE* stream);</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fseek</code>
    <ul>
      <li>int fseek(FILE* stream, long int offset, int whence);</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fgetc</code>, <code class="language-plaintext highlighter-rouge">getc</code>, <code class="language-plaintext highlighter-rouge">getchar</code>
    <ul>
      <li>int fgetc(FILE* stream);</li>
      <li>int getc(FILE* stream);</li>
      <li>int getchar();</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fputc</code>, <code class="language-plaintext highlighter-rouge">putc</code>, <code class="language-plaintext highlighter-rouge">putchar</code>
    <ul>
      <li>int fputc(int c, FILE* stream);</li>
      <li>int putc(int c, FILE* stream);</li>
      <li>int putchar(int c);</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">fgets</code>, <code class="language-plaintext highlighter-rouge">gets</code>
    <ul>
      <li>char* fgets(char<em>s, int n, FILE</em> stream);</li>
      <li>char* gets(char*s);</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">printf</code>, <code class="language-plaintext highlighter-rouge">fprintf</code>, <code class="language-plaintext highlighter-rouge">sprintf</code></p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">scanf</code>, <code class="language-plaintext highlighter-rouge">fscanf</code>, <code class="language-plaintext highlighter-rouge">sscanf</code></li>
</ul>

<h4 id="fopen">fopen</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">FILE *fopen(const char *filename, const
char* mode);</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">r</code> (å”¯è®€æ¨¡å¼)</li>
      <li><code class="language-plaintext highlighter-rouge">w</code> (å¯«å…¥æ¨¡å¼ã€é•·åº¦æ­¸é›¶)</li>
      <li><code class="language-plaintext highlighter-rouge">a</code> (å¯«å…¥æ¨¡å¼ã€é™„åŠ )</li>
    </ul>
  </li>
</ul>

<h4 id="2-printf-sprintf-fprintf">2. printf, sprintf, fprintf</h4>
<p>%d, %o, %x, %c ,%s ,%f (float) ,%e (double) ,%g (double)</p>

<h4 id="3-scanf-fscanf-sscanf">3. scanf, fscanf, sscanf</h4>
<p>%d, %o, %x, %f, %e, %g, %c, %s, %[] (æƒç„ç‰¹å®šå­—å…ƒ), %% (æƒç„ % çš„å­—å…ƒ)</p>
:ET